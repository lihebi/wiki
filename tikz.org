#+TITLE: Tikz

* Code Structure
First, use the package
#+BEGIN_SRC latex
  \usepackage{tikz}
#+END_SRC

Then load libraries
#+BEGIN_SRC latex
  \usetikzlibrary{shapes.multipart}
#+END_SRC

Optionally some settings (TODO). Except =\tikzset= command, all other
command should be put inside tikzpicture.
#+BEGIN_SRC latex
  \tikzset{>=latex}
  \tikzset{grid/.style={gray,very thin,opacity=1}}
#+END_SRC


To start a tikzpicture, you start the ={tikzpicture}= environment. It
is suitable to be put inside a ={figure}= env. This also means, if it
is not put inside a figure, it can actually be used as an inline
image. The baseline is the center of current line, and you can use
=/tikz/baseline= option to lower or raise it. This option is evaluted
at the end of drawing, thus have access to the node names defined. It
can also access the outmost =current bounding box=.
#+BEGIN_SRC latex
  \begin{figure*}[ht]
    \centering
    \begin{tikzpicture}[options]
    \end{tikzpicture}
    \caption{}
    \label{}
  \end{figure*}
#+END_SRC

=\tikz= command; is the same as begin and end =tikzpicture=, and put
command inside. At the end of this environment, tikz makes a guess
about the bounding box, which is updated whenever it encounters a
coordinate. This may be imprecise.

Finally, the background is transparent. In order to set to something
else, you need the =background= package.

# The most common errors for tikz are:
# - miss semicolon
# - miss curly braces
# - miss include tikz library
* Parameters (options)
The options are the same as using =\tikzset{options}=. Sometimes there
needs not a value, and it is interpreted like this:
- If key is a color, ~color=key~ is processed
- if key contains a /dash/, ~arrows=key~ is processed
- if key is a name of a shape, ~shape=key~ is processed.

They are specified in =key=value= pairs.

- color: a color can be the name (list TODO) or using xcolor
  extension, (color1!30!color2), where color2 is optional.
- line width. Expect a dimension. The following are /standalone/
  options, specifying to line width
  - ultra thin
  - very thin
  - semithick
  - thick
  - very thick
  - ultra thick
- Patterns
  - solid
  - dotted, densely dotted, loosely dotted
  - dashed, densely dashed, loosely dashed
  - dash dot, densely .., loosely ..
  - dash dot dot, densely .., loosely ..
  - double=<core color>
  - double distance=<dimension>

Path can be decorated, given =decorate= and
~decoration=<name>~. Possible names:
- zigzag


** Scope
Parameters can have scope. It is introduced by ={scope}= invironment,
taking the parameters as options,
i.e. ~\begin{scope}[key=value]~. Scopes can be nested, and have
lexcial scope. The top level ={tikzpicture}= env also acts like a
scope.

There's also a =every scope= option to install styless for every
scope.

The =scopes= package provide an easier way to specify scopes, using
just ={[options] ...}=. This is pretty useful for inside-path
scoping. One line scope command is also available as
=\scoped[options]<path command>=.

** Styles
Another way to group code together is to define a style. Like =help
lines= style. Styles are defined as an option, e.g.
#+BEGIN_EXAMPLE
my style/.style={draw=red, fill=red!20}
#+END_EXAMPLE
The =.style= means "these keys should not be applied immediately, but
rather a definition". Later reference to it is same as written the key
values literally.

There seems not to be a way to inherit a style, but rather, you can
~.append style~. The appended style is added to the end, and the last
style will win. There's also a ~.prefix style~ but not useful in this
case. The content of style can be parameterized, by =#n= where n
starts from 1. It seems that it will be replaced literally.

#+BEGIN_SRC latex
outline/.style={draw=#1, fill=#1!50},
outline/.default=black
#+END_SRC

Note 2 things:
1. the lexer is actually pretty good
2. can use default value (s?)

Use it as ~outline=blue~

* Coordinates
The general syntax is
#+BEGIN_EXAMPLE
([options] <coordinate spec>)
#+END_EXAMPLE

Options are optional, and coordinate spec can be any one of the
system. The options includes
- xshift=3cm
- shift=(x,y)

The Systems. /Inside/ each value, the arithmetic operations can be
used. All numbers can accept the following unit (pt, cm, TODO), and if no unit
is provided, it uses the coordinate system setting.

- =(x,y)=: xy-corredinate
- =(30:1cm)=: 1cm in the 30 degress direction.
- =(x,y,z)=: 3d

Node is also often used for specify a coordinate. The implicit way is
- (a)
- (a.north)
- (a.10): 10 degree angle
** Intersection

Yet another way is to use /perpendicular/ coordinate system. This
calculate the intersection.
- (2,1 |- 3,4): yield 2,4
- (3,4 -| 2,1)

A more general way to find intersection of two pathes is to use
=intersections= library (TODO).

** Relative position
- =++(x,y)=: You can also use relative position.  means shift to the
  /last point/ used.
- =+(x,y)=: similar to ++ but does not change the /last point/

Note that the scoping will not localize the position, thus to make a
local part "local", you can use the =/tikz/current point is local=
option.

** calc
The package =calc= provide calculation for coordinates. The general
syntax is:
#+BEGIN_EXAMPLE
([options] $<coordinate computation$)
#+END_EXAMPLE

The coordinate computation is roughly
#+BEGIN_EXAMPLE
compute ::= A [+-] A [+-] A ...
A ::= <factor>*<coordinate><modifiers>
#+END_EXAMPLE

Note that the <coordinate> must be surounded by =()=.  Modifiers can
be:
- partway modifier: =!number!angle:<second coordinate>=,
  e.g. =(1,2)!.75!(3,4)=. angle: is optional
- distance modifiers: =!dimension!angle:<second coordinate>=. This
  differs with partway that it is a concrete distance (like 1cm)
  instead of a percentage.
- projection modifiers: =(a)!(b)!(c)= means draw a line between a-c,
  and project b onto c, get the intersection point.

* Path
Path is a list of path operations. The coordinates can be =cycle=, literally.
Before each operation, options can be given. The option will apply to
ALL following path operations.
- rounded corners
- sharp corners
- color=red

There's a style set point as =/tikz/every path=.

Here are a list of all operations:
- move-to: (a)
- line-to:
  - straight line: -- (a)
  - horizontal and vertical line: -|(a) |-(a)
- curve-to: ..controls<c>and<d>..(a): and<d> is optional.
- rectangle: rectangle(a)
- circle and ellipse
  - circle[<options>]: the options are mandary. Set a =radius=. If set
    =x radius= and =y radius= differently, it will be a ellipse.
- arc operation: arc[<options>]: TODO
- grid operation: grid[<options>](a): add a grid filling the
  rectangle. Options include step, xstep, ystep. The typically used
  style is =help lines=.
#+BEGIN_EXAMPLE
\draw [help lines] (0,0) grid (3,2)
#+END_EXAMPLE
- parabola TODO
- sin/cos TODO
- svg TODO
- plot
- to path operation: to[<options>]<nodes>(a): nodes are the label
  nodes, there's a =every to= style option to style it. Options
  include =in= and =out= to set the degree of the in and out lines.
- foreach operation: foreach<variables>[<options>] in {values} {<path
  commands>}. E.g. =foreach \x in {1,...,3} {--(\x,1) -- (\x,0)}= This
  is weired.
- let operation: seems to bind variable to coordinates.
- scoping operation: ={}=
- node and edge operation (Separate)
- graph operation
- pic operation

* Actions (on path)
** Draw
- =\draw=: =\draw= is an abbreviation for =\path[draw]=. It will draw
  the entire path if this option appear /anywhere/ inside the
  path. The ~draw=color~ will specify the color.
- =\fill=: only for closed path. abbrev for =\path[fill]=. =\filldraw=
  is abbrev for =\path[fill,draw]=.
  - fill=<color>
  - pattern=<name> TODO list of patterns
    - dots
    - bricks
  - pattern color=<color>
- =\shade=: similarly there're =\shade= and =\shadedraw=
** Clip
- =\clip=: does NOT have =\clipdraw= because it seems not making
  sense. If you want, use =\path[draw,clip]= explicitly

clip can be nested, and the clipped area will be in effect for the
subsequent path. Those path will not affect the picture size. The only
way to end the clip is to close the scope. Thus scope is typically
used to create local clip, and clip is typically the first path in a
scope.

** Bounding box
A path can be used as a bounding box. It can be used in two ways, make
it smaller or bigger.

Smaller
#+BEGIN_EXAMPLE latex
  Letf\begin{tikzpicture}
  \draw[use as bounding box] (2,0) rectangle (3,1);
  \draw (1,0) -- (4.75);
  \end{tikzpicture}Right
#+END_EXAMPLE

The second draw will be out of the box of this picture, and strike
through the text.

Bigger
#+BEGIN_EXAMPLE latex
Left
\begin{tikzpicture}
\useasboundingbox (0,0) rectangle (3,1);
\fill (0.75, .25) cicle (.5cm);
\end{tikzpicture}
Right
#+END_EXAMPLE

The bounding box is larger than the filled circle, so the text will be
further apart.

There's a node =current bounding box=, which has the shape of
rectangle. For a single path, there's also a node called =current path
bounding box=. The tikzpicture env also supports a =trim left= (which
has a default of 0pt) and =trim right=. It will trim the bounding box,
not the figure.

* Arrow
Use the library =arrows.meta=.

Precoditions:
- have specified =arrows= or its short form (it must have a /dash/)
  (just put -> inside the path option)
- the tips must be valid
- [C] do not use clip
- [C] the path is not closed

Possible arrow specification (=startspec-endspec=) (arrows={xxx} is
the full spec):
- ->
- >-Stealth: the first > actually change the tail of the arrow
- -{Stealth[red]}: the red is applied to arrow tip. The option is
  inside the brackets, and multiple options can be provided,
  e.g. length, width, scale, scale length, scale width, color, fill,
  line width, round, sharp

** TODO Bending and flexing
** TODO arrow tips

* Node
Nodes are intend for putting text. Everytime a node command is fired,
it is inserted at the /current point/. A node has a shape, drawing a
node means draw the shape.

Predefined shape (TODO other shapes from libraries):
- rectangle
- circle
- ellipse

A node can have a name for future reference. It is given by
~name=<name>~ option, or by =node(name){text}=.

A node is created by a path operation, similar to other path
operations, but node is not part of the path itself.

The full syntax of the node:
#+BEGIN_EXAMPLE
node <foreach> [<options>] (<name>) at (<coordinate>) {<content>}
#+END_EXAMPLE

Everything between node and ={}= is optional, and the order does not
matter except foreach. The node will be put at the current point,
unless =at= presents.

** Options
Options are only applied to the node itself, possible options are:
- draw
- fill
- shape=rectangle, circle, ellipse
- behind path
- in front of path
- inner sep
  - inner xsep
  - inner ysep
- outer sep
  - outer xsep
  - outer ysep
- minimum size
  - minimum height
  - minimum width
** Foreach
Foreach works like this: the following create three nodes.  You can
also nest the loops.
#+BEGIN_EXAMPLE
\tikz \draw (0,0) node foreach \x in {1,2,3} at (\x,0) {\x};
\tikz \draw (0,0) node foreach \x in {1,2,3} foreach \y in {1,2,3} at (\x,0) {\x};
#+END_EXAMPLE

** Style
The style hooks are =every node= and =every circle node=, =every
rectangle node=, etc.

The scope will not influence the lexical scope of the node names. Thus
we can use another option =name prefix= and =name suffix= so that
every node names inside the scope will be renamed under the hood.

** TODO Multi-part node
** Node Text
Options
- text=<color>
- node font=<font command>
- font=<font command>: font command can be =\small=, etc.
- align: set the alignment. This also enables multiple line text.
  - left
  - flush left (use hyphen to break words)
  - right
  - flush right
  - center
  - flush center
  - justify (use variable spacing)
  - none
- text width
- text height
- text depth: seems useless

** Node Positioning
It uses anchor. The default is the center of the node. Possible anchors
- north east south west
- base, center

This is good enough, but the author thinks it is not intuitive enough,
thus he came up with some suger:
- above, below, left, right
- centered

*** TODO positioning
For more advanced placement, there's a library called
=positioning=. This package actually redefines the above, etc, thus
loading this package will make the program behaves differently. The
detail seems to be interesting.

** Fitting
This fits the scenario that you want a box that is just big enough to
hold something. You need to load the =fit= library.

You create a node, give fit as an option with the value of several
nodes.
#+BEGIN_EXAMPLE
\node[fit=(a) (b) (c)]
#+END_EXAMPLE

*** TODO how to get several boxes to hold several things, but those boxes are of same size and aligned?
** Place on a line
These continue the node options
- pos=<fraction>
  - midway: same as pos=0.5
  - near start 0.25
  - near end 0.75
  - very near start 0.125
  - very near end 0.875
  - at start 0
  - at end 1
- auto=<direction>: left, right
- swap: swap left and right. The short alias is ='=
- sloped: the text will be aligned with the line or on the tangent to
  the curve

** Label & Pin
This is used to add a node of text /next to another node/.

- label=[<options>]<angle>:<text>
  - the angle can be the following, if it is not specified, the value
    of =label position= is used.
    - a number as degree
    - anchor like north
    - above, below, left, right
  - =absolute= is a style. It will change the meaning of angle
  - label distance
  - every label: a style placeholder

- pin=[<options>]<angle>:<text>: it is very similar to label, the only
  difference is that it adds a line between the two nodes
  - pin distance
  - every pin
  - pin position
  - every pin edge
  - pin edge

The quotes syntax is very useful. It is in the library =quotes=. This
must be placed /inside the option of a node/. The format is
#+BEGIN_EXAMPLE
"<text>"<options>
#+END_EXAMPLE

options don't need to be surrounded by curly braces, unless there's a
comma in it (because the comma should mean the next option for the
/node/). If the text has comma or colon, it MUST be surrounded by
curly braces, like ="{hello, world}"=. This should be limitation of
parser.

- quotes mean label
- quotes mean pin
- every label quotes
- every pin quotes
- node quotes mean

** TODO 17.12 Edge and from here
* Pic
You can define some shape, and then reuse it at any place a node can
appear. But the pic itself cannot be referenced. But the node inside
pic can be referenced.

You define a pic by
#+BEGIN_EXAMPLE
\tikzset {
mypic/.pic = {
\draw (-3mm, 0) to [bend left] (0,0) to [bend left] (3mm,0)
}
};
#+END_EXAMPLE

Reuse it by
#+BEGIN_EXAMPLE
\tikz \draw (1,1) -- (2,2) pic {mypic} -- (3,2) pic {mypic};
#+END_EXAMPLE

The pic syntax is
#+BEGIN_EXAMPLE
pic [<options>] {<pic type>}
#+END_EXAMPLE

You can also draw some inline pics. Note that you still need the curly
brace, but leave it empty.
#+BEGIN_EXAMPLE
\tikz \pic [pics/code={\draw ...;}] {}
#+END_EXAMPLE

Pic can have actions, too, like
- red
- draw
- fill

Finally, to style pic, you can use =every pic=. You can use quote
syntax inside the option of pic, too.

* TODO Graph
The graph system is syntax suger for nodes, for the sake of creating a
lot of similar nodes. The =\graph= command is sure a DSL, /extending/
the DOT syntax.

#+BEGIN_SRC latex
\graph [grow down, branch right] {
  root -> {left, right -> {child, child}}
};
#+END_SRC


* TODO Tree
The node syntax can also be used to draw a tree. A node can be
followed by any number of children, each introduced by keyword
=child=. The children are also nodes, thus they can have children
using the same syntax. Trees have a set of options (TODO).

* TODO Matrix
#+BEGIN_SRC latex
\matrix {
  \node {}; & \node {}; \\
  \node {}; & \node {}; \\
};
#+END_SRC

* TODO Packages
** shapes.multipart
#+BEGIN_SRC latex
\usetikzlibrary{shapes.multipart}
#+END_SRC

It adds to the node following options:
#+BEGIN_EXAMPLE
mynode/.style={split, rectangle split parts=2}
#+END_EXAMPLE

