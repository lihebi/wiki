#+TITLE: R

#+begin_src R
library(class)
setwd("/absolute/path")
# the following can be the relative path to the above path
source("./xxx.R") # load a script
#+end_src

* Install package

Use Rstudio, install, select from local archive.
Download from CRAN website(binary), locate to that package in Rstudio to install.

** Trouble shooting

Error message on mac os x:

#+begin_src text
package 'multicore' is not installed for 'arch=x86_64'
#+end_src

Now you need to install from source.
Download source code, then use

#+begin_src text
R --arch x86_64 CMD INSTALL multicore_0.1-3.tar.gz
R --arch=i386 CMD INSTALL --libs-only multicore_0.1-3.tgz
#+end_src

As Matthew said at http://www.matthewckeller.com/html/64_bit_r_on_mac.html

#+BEGIN_QUOTE
The first command installs the package multicore for 64-bit architecture.
It will erase any existing ‘multicore’ library that exists at the default location where libraries are installed
(Library/Frameworks/R.framework/Resources/library).
The second command installs the package for 32-bit use in case you want that.
Make sure on the second command to include the --libs-only option or else you’ll erase your 64-bit package
and replace it with a 32-bit one.
#+END_QUOTE








* Vectors

all these assignments are equivalent

#+begin_src R
# c() can take an arbitrary number of vector arguments.
# return a vector got by concatenating its arguments end to end
> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
> x = c(10.4, 5.6, 3.1, 6.4, 21.7)
> x
# display x
> assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
#+end_src

operation on vector

#+begin_src R
> 1/x # will use 1 divides all 5 values of x, just like matrix in matlab
> y <- c(x, 0, x)
# the oprand does not need to be the same length
# The result is the longest, small ones repeat.
> v <- 2*x + y + 1
#+end_src

* Numbers
R will use double precision real numbers, or double precision complex numbers.

Always supply complex numbers explicitly:
`sqrt(-17)` will give NaN and a warning,
but `sqrt(-17+0i)` will do it.



* Logical

`TRUE`, `FALSE`, `NA`

 * `!a`
 * `a & b`
 * `a | b`

 * `is.na(x)`. never use x==NA, that will output a vector of lengh(x) with all NA

* String
`paste()` function takes an arbitrary number of arguments
and concatenates them one by one into character strings.
Any numbers given among the arguments are coerced
into character strings in the evident way,
that is, in the same way they would be if they were printed.

The recycling rule also takes place here.

#+begin_src R
> labs <- paste(c("X","Y"), 1:10, sep="")
# c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
#+end_src

* Objects

Two intrinsic attributes: mode and length.
Have two system functions:
`mode(object)` and `length(object)`.

 * mode: the basic type of its fundamental constituents



* array
** Sequences
 * `1:30`: c(1, 2, …, 29, 30)
 * and the colon operater has higher priority: `2*1:15` => c(2, 4, …, 28, 30)
 * `30:1`: backward
 * `seq(2,10)` => `2:10`
 * `seq(from=1, to=30)` == `seq(to=30, from=1)`

#+begin_src R
> seq(-5, 5, by=.2) -> s3
> s4 <- seq(length=51, from=-5, by=.2)
# x = [1,2,3]
> s5 <- rep(x, times=5) # put five copies of x end-to-end in s5
# [1,2,3,1,2,3,...]
> s6 <- rep(x, each=5) # repeats each element of x five times before moving on to the next.
# [1,1,1,1,1,2,2,2,2,2,...]
#+end_src


** Vector Indexing/Subseting/Slicing

#+begin_src R
> y <- x[!is.na(x)]
# x's none-NA elements.
> (x+1)[(!is.na(x)) & x>0] -> z
> x[6] # 6th element
> x[1:10] # first 10 elements
> c("x","y")[rep(c(1,2,2,1), times=4)]
# a character vector of length 16 consisting of "x", "y", "y", "x" repeated four times.
> y <- x[-(1:5)]
# all but the first five elements of x.
#+end_src

naming

#+begin_src R
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
#+end_src

change the subset:

#+begin_src R
> x[is.na(x)] <- 0
# replaces any missing values in x by zeros
> y[y < 0] <- -y[y < 0]
# is same as:
> y <- abs(y)
#+end_src


** Array

#+begin_src R
> dim(z) <- c(3,5,100)
# 3 by 5 by 100 array
> z[2,,] # is 5,100 array
> z[,,] # is the entire array
#+end_src

** indexing matrix

#+begin_src R
> x <- array(1:20, dim=c(4,5))   # Generate a 4 by 5 array.
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> i <- array(c(1:3,3:1), dim=c(3,2))
> i                             # i is a 3 by 2 index array.
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1
> x[i]                          # Extract those elements
[1] 9 6 3
> x[i] <- 0                     # Replace those elements by zeros.
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20
#+end_src

** outer product

#+begin_src R
> ab <- a %o% b
# the same as
> ab <- outer(a, b, "*")
#+end_src

we can change the function used in `outer`

#+begin_src R
> f <- function(x, y) cos(y)/(1 + x^2)
> z <- outer(x, y, f)
#+end_src

** matrix multiplication

#+begin_src R
> A * B # matrix of element by element products
> A %*% B # matrix product
> x %*% A %*% x # quadratic form ... 二次多项式 ax^2 + bxy + cy^2
#+end_src

** solve linear equation

#+begin_src R
> b <- A %*% x
# if b and A are given, but not x, x will contain the result
> solve(A,b) # will also solve the system.
# I'm not sure this should be execute after the previous statement.
#+end_src

* functions

 * +,-,`*`,/,^(power),
 * `log`, `exp`, `sin`, `cos`, `tan`, `sqrt`
 * `min`, `max`
 * `pmax` and `pmin`: parallel maximum and minimum functions
  a vector (of length equal to their longest argument) that contains in each element the largest (smallest) element in that position in any of the input vectors
 * `range` = c(min(x),max(x))
 * length(x), sum(x), prod(x) (product)
 * mean(x): sum(x)/length(x)
 * var(x): sum((x-mean(x))^2)/(length(x)-1)
 * sort(x): increasing order
 * order() or sort.list()

* Interactive
Be sure to enter a new work directory because `R` may store something in current directory.

Basic help:

#+begin_src R
R
> q()
> help(lm)
> help("if")
> ?lm
> example(topic)
> ??solve
#+end_src

Function command:

#+begin_src R
> source("a.R") # load another file
> sink("a.lis") # redirect output to a.lis
> sink() # retore output to stdio
> ls() # list the objects currently stored
> objects() # create and store current objects
> rm(x, y, z, ink, junk, temp, foo, bar) # remove objects

#+end_src
