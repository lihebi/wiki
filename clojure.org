#+TITLE: Clojure

# https://clojuredocs.org/quickref


The documen for clojure is terrible. I like the scheme and common-lisp
document better. I simply want to read a well sectioned document containing all things.
- the reference is part, not all
- the library API is not ordered at all
- the official cheatsheet contains duplicated items here and there
- the un-official manuals and cheatsheet are not complete

Suspend the interest for clojure for now.

- The [[file:clojure-other.org][old clojure page]]
- the [[file:clojure-tools.org][tools]] for clojure

- https://clojure.github.io/ is the API reference, in alphabet order


* clojure.core
- =*in*=
- =*out*=
- =*err*=

- assert


** Namespace
Namespaces are maps that map name to var. Namespace is seperated by
dot, similar to java. The recommended format: =org.lib.funcgroup=.

- =clojure.core/ns=: [name docstring? attr-map? references*]
  - set =*ns*= to name
  - references are same as calling them, except arguments are not quoted
    - (:refer-clojure ...)
    - (:require ...)
    - (:use ...)
    - (:import ...)
    - (:load ...)
    - (:gen-class)

- =require [& args]=: The scope will be available, the functions under
  them can be called using the scope.
  - load libs, skip already loaded.
  - do not usually use directly, use in =ns= instead
  - args can be a single symbol, or with options. It recognizes options
    - =:as sym=: as a symbol. e.g. =(require [clojure.walk :as walk])=
    - =:refer sym-list=: the list of symbols inside the lib can be
      called without the scope. The list can be =:all=
- =refer [ns-sym &filters]=: refer to all public vars of ns into
  current namespace. Filters:
  - :exclude list-of-symbols
  - :only list-of-symbols
  - :rename map-of-fromsymbol-tosymbol
- =refer-clojure [& filters]=: same as (refer 'clojure-core
  <filters>). clojure-core is refered by default, so this is typically
  used with exclude filter.
- =use [& args]=: do not use after clojure 1.4. Use =require= with
  =:refer= instead
  1. require
  2. refer the lib's namespace
- =import [& import-symbols-or-lists]=: as import a java classes and
  make them usable in their short name in clojure
  - since we have the rest sign =&=, the arguments are not inside a
    list, but as multiple arguments for import
  - as the argument name indicates, it can be symbol or list
    - symbol: is the full java class, e.g. =java.util.Date=
    - list: to save some typing, if importing multiple classes from
      same namespace: =[java.util.concurrent Executors TimeUnit]=

* Type
** Number
*** Arithmetic
- +-*/
- quot
- rem
- mod
- inc
- dec
- max
- min
- with-precision

*** Compare
- =
- ==
- not=
- <, <=, >, >=

*** Bitwise
- bit-and
- bit-or
- bit-xor
- bit-flip
- bit-not
- bit-clear
- bit-set
- bit-shift-right
- bit-shift-left
- bit-test

*** Cast
- byte
- short
- int
- long
- float
- double
- bigint
- bigdec
- num
- rationalize
*** Predicate
- nil?
- identical?
- zero?
- pos?
- neg?
- even?
- odd?

Other
- number?
- rational?
- integer?
- ratio?
- decimal?
- float?
*** Random
- rand
- rand-int


** symbols & keywords
literals for keywords: =:kw=, =:my.ns/kw=, =::in-cur-ns=


** String
*** Use
- count
- get
- subs

- join
- escape
- split
- split-lines
- replace
- replace-first
- reverse
- index-of
- last-index-of
*** Regex
- #"pattern"
- re-find
- re-seq
- re-matches
- re-pattern
- re-matcher
- re-groups
- replace
- replace-first
- re-quote-replacement
*** Letter
- capitalize
- lower-case
- upper-case
*** trim
- trim
- trim-newline
- triml
- trimr
*** Predicate
- string?
- blank?
- starts-with?
- ends-with?
- includes?
*** characters
- literals: =\a= =\newline=
- char
- char?
- char-name-string
- char-escape-string


* Collections
** Collection
*** Generic
- count
- empty
- not-empty
*** ops
- into
- conj
- walk
- prewalk
- prewalk-demo
- prewalk-replace
*** Predicates
- distince?
- empty?
- every?
- not-every?
- some
- not-any?
*** Capabilities
- sequential?
- associative?
- sorted?
- counted?
- reversible?
- coll?
- list?
- vector?
- set?
- map?
- seq?
- record?
- map-entry?
** List
- list
- list*
- first
- nth
- peek
- .indexOf
- .lastIndexOf
- cons
- conj
- rest
- pop

** Vector
*** Create
- =[ ]=
- vector
- vec
- vector-of
- mapv
- filterv
- vector-of
*** Examine
- nth
- get
- peek



