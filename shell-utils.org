#+TITLE: Shell Utilities

* Mathematics
** random number generation
#+BEGIN_SRC shell
shuf -i 1-100 -n 1
#+END_SRC
- =bc= calculator

* Text Editing

** Patch System
Create a patch (notice the order: old then new):
#+BEGIN_EXAMPLE
diff -u hello.c hello_new.c > hello.patch
diff -Naur /usr/src/openvpn-2.3.2 /usr/src/openvpn-2.3.4 > openvpn.patch
#+END_EXAMPLE

To apply a patch
#+BEGIN_EXAMPLE
patch -p3 < /path/to/openvpn.patch
patch -p1 <patch -d /path/to/old/file
#+END_EXAMPLE

the number after =p= indicates how many the leading slashes are skipped when find the old file

To reverse (un-apply) a patch:

#+BEGIN_EXAMPLE
patch -p1 -R <patch
#+END_EXAMPLE

This works as if you swapped the old and new file when creating the patch.

** grep
#+begin_src shell
# -i: 忽略大小写
# -n: 显示行号
# -v: 输出不匹配的行
# -H: 同时输出此行所在的文件名
grep <pattern> <file>
#+end_src
** tr: translate characters

tr <string1> <string2>

the characters in string1 are translated into the characters in string2
where the first character in string1 is translated into the first character in string2 and so on.  If string1 is longer than string2,
the last character found in string2 is duplicated until string1 is exhausted.

characters in the string can be:

any characters will represent itself if not:

 * ~\\octal~: A backslash followed by 1, 2 or 3 octal digits
 * ~\n~, ~\t~
 * ~a-z~: inclusive, ascending
 * ~[:class:]~: space, upper, lower, alnum
  - if ~[:upper:]~ and ~[:lower:]~ appears in the same relative position, they will correlate.

** uniq: report or filter out repeated lines in a file
Repeated lines in the input will not be detected if they are not adjacent,
so it may be necessary to sort the files first.

 * ~uniq -c~: Precede each output line with the count of the number of times the line occurred in the input, followed by a single space.
 * ~-u~: Only output lines that are not repeated in the input.
 * ~-i~: Case insensitive comparison of lines.

** Other
- ~cat~: ~-n~ output with line number
- tail
  - ~-<n>~ 显示后n行
  - ~+<n>~ 显示第n行到结尾
  - ~-F~ 跟踪显示不断增长的文件结尾

* System Management
** man
~man [num] <item>~
- =2=: system call, kernel function
- =3=: library call

** sort
 * ~-n~: compare according to string numerical value
 * ~-r~: reverse

** xargs
相当于~~，并把输出放 /结尾/
#+begin_src shell
find /etc -name '*.conf' | xargs ls -l
# the same as:
ls -l ~find ...~
#+end_src

** Find
#+begin_src shell
find . -type f -name *.flac -exec mv {} ../out/ \;
#+end_src
Copy file based on find, and take care of quotes and spaces:
#+begin_src shell
find CloudMusic -type f -name "*mp3" -exec cp "{}" all_music \;
#+end_src

** Filesystem related
from relative path to absolute path
#+BEGIN_SRC shell
realpath -f /relative/path # this will follow symbolic link
#+END_SRC

=du=: estimate file space usage
#+BEGIN_SRC shell
du -sm * | sort -nr
#+END_SRC



** Other
- ~time <command>~: # the total user and system time consumed by the shell and its children
- ~column~: formats its input into multiple columns. ~mount | column -t~
- ~dd~: ~dd if=xxx.iso of=/dev/sdb bs=4m; sync~
- ~convert~: ~convert xxx.jpg -resize 800 xxx.out.jpg # 800x<height>~
- ~nl~: ~nl <filename>~ 添加行号。输出到stdout
- ~ln~: ~ln -s <target> <linkname>~ 记忆：新的东西总要最后才发布。
- ~ls~: order: ~-r~ reverse; ~-s~ file size; ~X~ extension; ~-t~ time
- ~tree~
  - ~-d~ 只显示目录
  - ~-f~ 显示路径
  - ~-F~ 条目后有 [\*/=@|]
  - ~-r~ 倒序
  - ~-t~ 修改时间排序
  - ~-L(\d)~ 显示n层
