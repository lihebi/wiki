#+TITLE: C

* Tmp
=~= yields one's complement of an integer, i.e. sets 1 to 0 and 0 to 1
for all bits.

* Type
Tips for primitive types
- When using =char=, you must indicate whether it is signed or
  unsigned, because the default is system dependent.
- Most likely, =long= is same as =int=. So when you want a large
  number, use =long long=.

=sizeof= is *compile-time* operator. It has two forms: =sizeof
object=, =sizeof(type name)=.

Structure is of form =struct [tag] {};=.  This is a structure
definition. The tag is optional. If no tag, it just announce a
template of structure type, and nothing happens. If has tag, the tag
can be used later to refer to just this structure (scope??). Since it
is a type, it can define some variables just at the same time.

Initializers for structure is a list of initializers for each of the
members, surrounded by braces. For automatic variables, the
initializer can also be assignment from just another value of the same
structure type.
** storage class & linkage type
Internal and external are relative to a function. /Internal/ to a
function includes the arguments and variables defined inside the
function. Internal variables are /automatic variables/, because they
are allocated to temporary storage, and get out of space when the
function returns.

/External/ to a function refers to the external variables and
functions. All functions must be external, because C does not allow
definition of functions inside function. By default, external
variables and functions have the property that, all references by the
*same name*, even if compiled separately in separate files, will refer
to the same thing. This is called /external linkage/. To change the
linkage type, use =static= to limit an external variable or function
inside this file.

The /scope/ of a name is the part of program within which the name can
be used. Scope of an automatic variable is the body of the
function. The scope of an external variable or function lasts from the
point it is *declared* to the end of the file.  If a function or
variable is not in scope, it must be declared before usage. This is
done by a =extern= keyword. The declaration only *announces* the
properties of it, while the definition allocate the storage. There
must be only one definition of an external variable among all files
that make up the program. Array size must be specified in the
definition, but optional to an =extern= declaration. Initialization of
an external variable goes only with the definition.

For a /non-automatic variable/ (including static variables and
external variables), the initialization is done once only,
*conceptually* before the program starts executing. If no initializer,
it is initialized to 0. If has, the initializer must be a *constant
expression*. On the other hand, an /automatic variable/ is initialized
every time the function or block is entered, and the initializer can
be *any expression*, this is just a shorthand for assignment
statement. If there's no initializer, the default value is
*undefined*. An array can be initialized by assigning a list of
initializers enclosed in braces separated by commas, and the length,
when omitted, can be computed by the length of the initializers. If
there are fewer initializers than the size, the rest will be
initialized to 0, even for automatic variables. A string constant can
serve as an initializer array of characters.

/Extern "C"/ makes a function-name in C++ have 'C' linkage, i.e.
compiler will not mangle the function name. C++ can overload function
names, thus internally the compiler cannot just use function name to
refer to the function. It add argument/parameter type information to
the name used for linkage. However, C does not allow function
overloading, thus C compiler expect just the original name, but
couldn't find one because the name is modified. Thus, when you state
that a function has extern "C" linkage in C++, the C++ compiler does
not modify it, thus it is suitable to use in C code.

It can be applied to either an individual declaration or definition,
or a whole block of code.

#+begin_src C
extern "C" void foo(int);
extern "C" {
   void g(char);
   int i;
}
#+end_src

** register
A register declaration /advises/ the compiler that this variable will
be heavily used.

** restrict
The restrict keyword is a declaration of *intent given by the
programmer* to the compiler.  It says that for the lifetime of the
pointer, only it or a value directly derived from it (such as
pointer + 1) will be used to access the object to which it points.
This limits the effects of pointer aliasing, aiding optimizations.  If
this intention is not followed and the object is accessed by an
independent pointer, this will result in undefined behavior.

** volatile
The keyword tells the compiler that the value of the variable may
change at any time.  It may change unexpectedly, so DO NOT optimize
the code when you compiler think it would not change.

It is most commonly to declare a pointer to be volatile, and most
likely you do not intent to declare the place it points to be
volatile.

#+begin_src C
volatile int foo;
volatile uint8_t *pReg;
int * volatile p; // very rare
volatile int * volatile p; // very rare
#+end_src

The common use-case is
1. The register's value may change by hardware.
2. global variables modified by interrupt
3. global variables accessed by multiple threads

* Standard Libraries

** DONE stdio.h
- types:
  - =size_t=
  - FILE

Macro: =NULL=

#+begin_src haskell
remoev :: String -> Int
rename :: String -> String -> Int
tmpfile :: () -> FILE
tmpnam :: String -> String
fclose :: FILE -> Int
fflush :: FILE -> Int
fopen :: String -> Mode -> FILE
freopen :: String -> Mode -> FILE -> FILE
-- TODO setvbuf
fprintf :: FILE -> FormatString -> Int
fscanf :: FILE -> FormatString -> Int
printf :: FormatString -> Int
snprintf :: String -> Int -> FormatString -> Int
sprintf ::  String -> FormatString -> Int
sscanf :: String -> FormatString -> Int
#+end_src

character IO
fgetc :: FILE -> Int
fgets :: String -> Int -> FILE -> String
fputc :: Int -> FILE -> Int
fputs :: String -> FILE -> Int
getc :: 
#+begin_src c
int fgetc(FILE *stream);
char *fgets(char *s, int n, FILE *stream);
int fputc(int c, FILE *stream)
int fputs (char *s, FILE *stream)
int getc(FILE *stream)
int getchar(void)
char *gets(char *s)
putc
puts
ungetc
#+end_src

- File
  - fgetc
  - fgets
  - fputc
  - fputs
- stdin
  - getc
  - getchar
  - gets
  - putc
  - putchar
  - puts
- Put Back
  - ungetc
- Low-level
  - fread
  - fwrite
  - fgetpos
  - fseek
  - fsetpos
  - ftell
  - rewind
  - clearerr
  - feof
  - ferror
  - perror
** ctype.h
mapping of characters.

#+begin_src haskell
isalpha :: Int -> Bool
isblank :: Int -> Bool
iscntrl :: Int -> Bool
isdigit :: Int -> Bool
isgraph :: Int -> Bool
islower :: Int -> Bool
isprint :: Int -> Bool
ispunct :: Int -> Bool
isspace :: Int -> Bool
isupper :: Int -> Bool
isxdigit :: Int -> Bool
tolower :: Int -> Int
toupper :: Int -> Int
#+end_src
** signal.h

#+begin_src haskell
signal :: Int -> Func -> ()
raise :: Int -> Int
#+end_src
** math.h
First, trigonometric functions. The f-suffix is =float=, l-suffix is
=long double=
#+begin_src haskell
acos :: Double -> Double
asin :: Double -> Double
atan :: Double -> Double
atan2 :: Double -> Double -> Double
cos :: Double -> Double
sin :: Double -> Double
tan :: Double -> Double
#+end_src

#+begin_src haskell
exp :: Double -> Double
log :: Double -> Double
log10 :: Double -> Double
hypot :: Double -> Double -> Double -- sqrt (x^2 + y^2)
pow :: Double -> Double -> Double
sqrt :: Double -> Double
ceil :: Double -> Double
floor :: Double -> Double
round :: Double -> Double
trunc :: Double -> Double
#+end_src
** stdlib.h
- Conversion
  - atof
  - atoi, atol, atoll
  - strtod, strtof, strtold
  - strtol, strtoll, strtoul, strtoull
- Random
  - rand
  - srand
- Memory
  - calloc
  - free
  - malloc
  - realloc
- other
  - abort
  - exit
  - getenv
  - system
- arithmetic
  - abs
  - div
** string.h
- Copy
  - memcpy
  - memmove
  - strcpy
  - strncpy
  - strcat
  - strncat
- Compare
  - memcmp
  - strcmp
  - strcoll: seems to be strcmp with locale
  - strncmp
  - strxfrm: also some sort of strcmp
- Search
  - memchr
  - strchr
  - strrchr
  - strstr
  - strtok: tokenize
- Other
  - memset
  - strerror
  - strlen
** time.h

Types
- clock_t
- time_t
- struct tm

functions
- clock
- difftime
- mktime
- time
- asctime
- ctime
- gmtime
- strftime

** Simple Ones
*** assert.h
Make the macro =assert= available.
*** complex.h
This works with complex arithmetic. Not interesting.

*** errno.h
Error reporting macros. Not interesting
*** fenv.h
For floating point environment. Not interesting.
*** float.h
Seems to contain nothing.
*** inttypes.h
It includes =stdint.h= and extend it. Not interesting
*** iso646.h
Macros for logical comparators. E.g. =and= for =&&=.
*** limits.h
Nothing interesting.
*** locale.h
Formatting of numerical values. Locale related. Not interesting.

*** setjmp.h
Defines the macro =setjmp=, type =jmp_buf=, function =longjmp=.

*** stdarg.h
Variable arguments.

- type: =va_list=
- macros
  - va_start
  - va_arg
  - va_end
  - va_copy

#+begin_src c
type va_arg(va_list ap, type);
void va_copy(va_list dest, va_list src);
void va_end(va_list ap);
void va_start(va_list ap, parmN);
#+end_src

*** stdbool.h
macro =bool= expands to =_Bool=. Also defines =true= =false= as macros.

*** stddef.h
- macros: =NULL=

*** stdint.h
Nothing
*** tgmath.h
Generic math. Nothing interesting.

*** wchar.h
Wide character. Nothing special.
*** wctype.h
