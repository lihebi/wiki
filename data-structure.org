#+TITLE: LeetCode Used Data Structure


** Trie

*** 79. Word Search I

Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring.
The same letter cell may not be used more than once.

No magic here, try to start from each cell.
Recur the four directions, so that the back-tracing is automatic by recurrence.

#+BEGIN_SRC C++
class Solution {
public:
  bool exist(vector<vector<char>>& board, string word) {
    if (board.empty() || board[0].empty()) return false;
    for (size_t i=0;i<board.size();i++) {
      for (size_t j=0;j<board[0].size();j++) {
        if (recur(board, word, i, j, 0)) return true;
      }
    }
    return false;
  }
  bool recur(vector<vector<char>> &board, string word, int x, int y, int idx) {
    // std::cout << "recur: " << x << "," << y  << "\n";
    if (idx >= (int)word.size()) {
      return true;
    }
    if (x < 0 || y < 0 || x >= (int)board.size() || y >= (int)board[0].size()) {
      // std::cout << "  <--"  << "\n";
      return false;
    }
    if (board[x][y] != word[idx]) {
      // std::cout << "  <--"  << "\n";
      return false;
    }
    if (board[x][y] == word[idx]) {
      char c = board[x][y];
      board[x][y] = '\0';
      if (
          recur(board, word, x+1, y, idx+1)
          || recur(board, word, x, y+1, idx+1)
          || recur(board, word, x-1, y, idx+1)
          || recur(board, word, x, y-1, idx+1)
          ) return true;
      board[x][y] = c;
      return false;
    }
    return false;
  }
};
#+END_SRC

*** Trie
The implementation is easy, but know when to use it is hard!
#+BEGIN_SRC C++
class TrieNode {
public:
  TrieNode() {
  }
  TrieNode *child(char c) {
    if (m_map.count(c) == 1) return m_map[c];
    return NULL;
  }
  TrieNode *addChild(char c) {
    TrieNode *node = new TrieNode();
    m_map[c] = node;
    return node;
  }
  bool isLeaf() {
    return m_isleaf;
  }
  void setLeaf() {
    m_isleaf = true;
  }
  bool hasChild() {
    return !m_map.empty();
  }

private:
  std::map<char, TrieNode*> m_map;
  bool m_isleaf = false;
};

class Trie {
public:
  Trie() {
    root = new TrieNode();
  }

  // Inserts a word into the trie.
  void insert(string word) {
    TrieNode *node = root;
    for (char c : word) {
      if (node->child(c)) {
        node = node->child(c);
      } else {
        node = node->addChild(c);
      }
    }
    node->setLeaf();
  }

  // Returns if the word is in the trie.
  bool search(string word) {
    TrieNode *node = root;
    for (char c : word) {
      if ((node = node->child(c))) {
      } else {
        return false;
      }
    }
    if (node->isLeaf()) {
      return true;
    }
    return false;
  }

  // Returns if there is any word in the trie
  // that starts with the given prefix.
  bool startsWith(string prefix) {
    TrieNode *node = root;
    for (char c : prefix) {
      if ((node = node->child(c))) {
      } else {
        return false;
      }
    }
    return true;
  }

private:
  TrieNode* root;
};
#+END_SRC

*** 212. Word Search II

We only carry the TrieNode, and it should store the word, aka the value.
#+BEGIN_SRC C++
class Solution {
public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    // construct a trie for all the words to search
    // continue to do the recursive method
    // keep the track of current value
    // if cannot search it on trie, stop the recursion along this line
    Trie trie;
    for (string s : words) {
      trie.insert(s);
    }
    for (int i=0;i<(int)board.size();i++) {
      for (int j=0;j<(int)board[0].size();j++) {
        recur(board, i, j, trie.getRoot());
      }
    }
    vector<string> retv (ret.begin(), ret.end());
    return retv;
  }
  void recur(vector<vector<char> > &board, int i, int j, TrieNode *node) {
    if (!node) {return;}
    if (node->isLeaf()) ret.insert(node->Value());
    if (!node->hasChild()) {return;}
    if (i < 0 || j < 0 || i >= (int)board.size() || j >= (int)board[0].size()) {return;}
    if (node->child(board[i][j])) {
      char c = board[i][j];
      board[i][j] = '\0';
      node = node->child(c);
      recur(board, i, j-1, node);
      recur(board, i, j+1, node);
      recur(board, i-1, j, node);
      recur(board, i+1, j, node);
      board[i][j] = c;
    } else {
      return;
    }
  }
private:
  set<string> ret;
};
#+END_SRC


** prefix tree

Alias: =Trie=, =Prefix Tree=, =Radix Tree=

It is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings


https://farm8.staticflickr.com/7527/16078670017_18478a43e5_o.png


*** Radix Tree

A radix tree (also patricia trie or radix trie or compact prefix tree) is a space-optimized trie data structure where each node with only one child is merged with its parent.

Unlike in regular tries, edges can be labeled with sequences of elements as well as single elements.

https://farm8.staticflickr.com/7533/16264560645_3ec5648d69_o.png


** Aho Corasick

It is a multiple string match algorithm. =fgrep= is based on this.


*** Construct Trie

https://farm8.staticflickr.com/7572/16085105388_86fedb2235_o.png

dictionary: ={a,ab,bab,bc,bca,c,caa}=

***  Node

The data structure has one node for every prefix of every string in the dictionary.
So if (bca) is in the dictionary,
then there will be nodes for (bca), (bc), (b), and ().

***  Color

If a node is in the dictionary then it is blue node.
Otherwise it is a grey node.

***  blue arc

a blue directed "suffix" arc from each node to the node that is the longest possible strict suffix of it in the graph.
For example, for node (caa), its strict suffixes are (aa) and (a) and ().
The longest of these that exists in the graph is (a).
So there is a blue arc from (caa) to (a).

***  Green Arc

There is a green "dictionary suffix" arc from each node to the next node in the dictionary that can be reached by following blue arcs. For example, there is a green arc from (bca) to (a) because (a) is the first node in the dictionary (i.e. a blue node) that is reached when following the blue arcs to (ca) and then on to (a).

*** Match Process

At each step, the current node is extended by finding its child,
and if that doesn't exist, finding its suffix's child,
and if that doesn't work, finding its suffix's suffix's child,
and so on, finally ending in the root node if nothing's seen before.
