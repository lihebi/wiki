#+TITLE: Racket
* Black Magic
http://www.greghendershott.com/2015/07/keyword-structs-revisited.html
#+BEGIN_SRC racket
  (begin-for-syntax
    (define syntax->keyword (compose1
                             string->keyword
                             symbol->string
                             syntax->datum)))
#+END_SRC
* TODO Haskell

* Pattern Matching (racket/match)
The syntax:

#+BEGIN_SRC racket
  (match val-expr clause ...)

  clause = [pat [#:when cond-expr] body ...+]
#+END_SRC
cond-expr is in teh scope of pat (to have the bind or not??).

The clauses are checked one-by-one, and the body of first match will
be in the tail position.

Pattern can be
- =_= to match anything and abandon it.
- a single id which matches anything and bind to it. An ID can appear
  more than once, in which case the pattern is considered matching
  only if all of the bindings of ID are same.
  - e.g. =(list a b a)= will not match ='(1 2 3)=, but will match ='(1
    2 1)=
- a list which binds to the destruction. 
- The quote can not be used to construct list of symbols, it will
  match verbatically instead. For that, use quasiquote, which supports
  the evaluation and splice-eval.
  - e.g. =`(1 ,a ,b)= will match ='(1 2 3)= with =a= and =b= bound.
- hash-table can be used to match the key and values, Using =...= in
  it means collect into a list.
  - e.g. =(hash-table ("key1" a) ("key2" b))=.
  - e.g. =(hash-table (key val) ...)= will match =#hash(("a" . 1) ("b"
    . 2))=, and key will be ='("b" "a")=
- cons can be used to match pairs
- =struct-id= can be used to match fields by position. Use =(struct
  struct-id _)= to match an instance of structure itself. E.g.
  - for structure =(struct tree (val left right))=
  - pattern =(tree a (tree b  _ _) _)= will match
  - =(tree 0 (tree 1 #f #f) #f)=
  - with =a= bound to 0, =b= bound to 1
- =and= is used to combine a list of patterns. The typical usage is
  =(and id pat)= where you can bind =id= and still check the =pat=
  against the entire value. =or= is also available but not that
  useful.

* Macros
Matthias Felleisen boils down macros into three main categories:
1. Binding form
2. Change order of evaluation
3. Make DSLs

Different from common lisp where you have compile time and runtime,
racket has the concept called /level/. The level 0 is roughly runtime,
and level 1 is compile time. But there're also level -1 and level 2,
3, ..., thus it is more general. But typically the first two levels
are used.

When using racket syntax, you typically need to require the base
library for it, by =(require (for-syntax racket/base))=.

Everything boils down to =define-syntax= and =syntax-case=.
=define-syntax= is nothing fancy. It just define a binding, same as
define, but the binding is in effect at level 1. Thus actually we
typically still define it as a lambda expression, thus it has the
shorthand to write argument (stx) in the same line. =syntax-rules=
itself is a lambda expression surounding =syntax-case=. Thus second
form does not use syntax-rules, but use syntax-case directly.

#+BEGIN_SRC racket
  (define-syntax foo
    (syntax-rules ()
      ((_ a ...) (printf "~a\n" (list a ...)))))
  ;; <=>
  (define-syntax (foo stx)
    (syntax-case stx ()
      (_ a ...)
      #'(printf "~a\n" (list a ...))))
#+END_SRC

=syntax-case= match a given syntax object against patterns, and return
another syntax object. It is doing the transformation. You can
actually do the transformation yourself, using =sytax->datum=,
operates on it, and use =datum->syntax= to convert it back. So
=syntax-case= just provides an easier way to do that, in the sense
that you don't need to convert explicitly. Instead, you specify by
position the argument, to match the datum, and construct a syntax
object as a result.

#+BEGIN_SRC racket
  (syntax-case stx-expr (literal-id ...)
    [pattern result-expr] ...)
#+END_SRC

Note the result is =result-expr=, that means the expr is going to be
executed, and the return value should be a syntax object.

#+BEGIN_SRC racket
  (define-syntax (foo stx)
    (syntax-case stx ()
      [(_ a b c)
       #'(if a b c)]))
#+END_SRC

See, stx is matched against the pattern =(_ a b c)=, and
destructed. =a b c= can then be used to construct the returned syntax
object. Note, the return must be a syntax object, it replaces the (foo
xxx) and be evaluated. The first is =_= because we don't care about
the leading identifier =#'foo=.

=syntax-rules= is a lambda expression, that calls =syntax-case= to
return a syntax object. It is used to define multiple patterns and
templates at one time. Note that the result is a "template" instead of
"expr", meaning it is restricted: cannot run any code, merely return
the template as if quoted. Thus when using syntax-rules, the result
need not be quoted by =syntax=.

#+BEGIN_SRC racket
  (syntax-rules (literal-id ...)
    [(id . pattern) template] ...)
  ;; <=>
  (lambda (stx)
    (syntax-case stx (literal-id ...)
      [(generated-id . pattern) (syntax-protect #'template)] ...))
#+END_SRC

=define-syntax-rule= is shorthand for =define-syntax= and
=syntax-rules=. The pattern is a list, the first is an identifier, the
following are pattern variables that matches anything. The template is
the constructed form to replace the old form. It is not quoted,
because it uses syntax-rules to construct. All pattern variables will
be replaced by the actual form.

#+BEGIN_SRC racket
  (define-syntax-rule (id . pattern) template)
  ;; <=>
  (define-syntax id
    (syntax-rules ()
      [(id . pattern) template]))
#+END_SRC
This is so constrained. The following is equivalent to the above:
#+BEGIN_SRC racket
  (define-syntax-rule (foo a b c)
    (if a b c))
#+END_SRC

=with-syntax= is often used to nest syntax. It is like =let= but is
able to bind pattern variables.
#+BEGIN_SRC racket
(syntax-case <syntax> () [<pattern> <body>] ...)
(syntax-case (list stx-expr ...) () [(pattern ...) (let () body ...+)])
;; <=>
(with-syntax ([<pattern> <stx-expr>] ...) <body> ...+)
#+END_SRC

** Reader
To understand how macro works, we need to know how the reader handles
the program.

A datum is the basic output of a read. Datum can be compound, in which
case the reader is recursively read the components. Some datums are
interned by the reader, i.e. their values are always =eq?= when they
are =equal?=. Such datums includes: symbols, keywords, strings, byte
strings, regexps, characters, numbers.

Some special read notation:
- =#(1 2 3)= for vectors
- =#s(struct-id 1 2 3)= for prefab structure types. note that for
  complex structure, the print format is not intuitive.
- =#hash(("a" . 5) ("b" b))= for hash tables
** Syntax Model
A /syntax object/ is a simple racket value + scope set + phase level.

When require something, those functions are not visible in
level 1. Thus if you want to use those when macro expands, you need
=(reqire (for-syntax racket/base))=.  Similarly, =for-meta= can be
used to specify any number as shift level.

Similaryly, a top-level =begin= is not visible in macro, we need
=begin-for-syntax= to bind variables to use at level 1.

Use these to expand a macro:
- =(expand top-level-form)=: fully expand
- =(expand-once top-level-form)=: expand only once
* rackunit
Since racket has the =test= module concept, there needs no unit test
framework. However, it seems that =rackunit= provides some
predicate functions.

In racket, each file is a module with the file name as the module
name. You can define a submodule using =module*= and =module+=. The
former can only appear exactly once for each module, while the latter
can appear multiple times, all of them concatenated into a single
module as if using =module*=.

Thus, folks typically use =module*= to define a =main= module, which
will be run by racket after the enclosing module by
=racket=. =module+= is used to define =test= modules, and will be
executed by =raco test= command.

=rackunit= provides check APIs and also organize tests into cases and
suites.  A check is a simple check, like equality. A test case is a
group of checks. If one of them fails, the following will not be
executed, and the test case fails. A suite is a group of test cases,
and has a name.

Check APIs (all of them accepts an optional message at the end):
- =check-eq?=
- =check-not-eq?=
- =check-equal?=
- =check-not-equal?=
- =check-pred pred v=: check if apply pred on v will produce
  other than #f
- ~check-= v1 v2 epsilon~: |v1-v2| <= epsilon
- =check-true v=: #t
- =check-false v=: #f
- =check-not-flase v=: not #f
- =check op v1 v2=: generic form, op is =(-> any any any)=
- =fail=: fail unconditionally, useful when developing to mark some tests

The following does not accept message, because they are straightforward:
- =check-match v pattern=: check if v match pattern

=test-begin expr ...= is used to group exprs, while =test-case name
body ...+= accept a name for them, and get reported if test fails.

Test suites are not going to run by default. This allows you to
specify which tests to run. There're text (=run-tests= in
=rackunit/text-ui=) and gui (=test/gui= in =rackunit/gui=) interfaces
to select tests. Create a suite using =(test-suite name-expr test
...)=. The tests can be single check or a test case.

* Trouble shooting

** racket cannot find browsers
Browsers are declared in sendurl.rkt, with

#+BEGIN_SRC racket
  (define all-unix-browsers
    '(
      firefox
      google-chrome
      galeon
      opera
      mozilla
      konqueror
      ;; ...
      ))
#+END_SRC

chromium is not in the list, thus
#+BEGIN_SRC racket
(require net/sendurl)
unix-browser-list ;; empty
(send-url "google.com") ;; error
#+END_SRC

The trick is to create a soft link for chromium named "google-chrome".
Also, the default is using firefox ... So I need to make sure firefox
is uninstalled. Is there a better way to configure browser??

The =racket-doc= will use the local racket document to search, thus in
order for it to work, install =racket-doc= package.



* Logger

#+BEGIN_SRC racket
  (define lg (make-logger))
  (define rc (make-log-receiver lg 'debug))
  (current-logger lg)
  (void
   (thread
    (lambda () (let loop ()
                 (print (sync rc))
                 (loop)))))
  (log-error "error")
  (log-fatal "fatal")
  (log-debug "just a debug")
#+END_SRC

#+BEGIN_SRC racket
  (require racket/logging)
  (let ([my-log (open-output-string)])
    (with-logging-to-port my-log
      (lambda ()
        (log-warning "Warning World!")
        (+ 2 2))
      'warning)
    (get-output-string my-log))
#+END_SRC
