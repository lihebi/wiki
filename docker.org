#+TITLE: Docker

Install =docker= package and start the service by
#+BEGIN_EXAMPLE
systemctl start docker
systemctl enable docker
#+END_EXAMPLE

We can build Debian image easily on Arch:

#+BEGIN_EXAMPLE
mkdir jessie-chroot
# debootstrap jessie ./jessie-chroot http://http.debian.net/debian/
# cd jessie-chroot
# tar cpf - . | docker import - debian
# docker run -t -i --rm debian /bin/bash
#+END_EXAMPLE

Re-launch a stopped container can be done by =docker start
<container>= and will be detached by default if it is run by that.

You can assign a name to the container so that you can better remember
and reference it.

* General operations

- docker images :: list images
- docker images <name> :: list images whose name is "name" (can have different) tags
- docker run [option] <image> /bin/bash :: run a *fresh* container based on the image.
  - -i :: interactive
  - -d :: detach (opposite to -i)
  - -t :: assign a tty. Even when using -d, you need this.
  - -p <port> :: export the port <port> of the container. The host
                 port will be randomly assigned. Running =docker ps=
                 will show the port binding information.  If the port
                 is not set when running a container, you have to
                 commit it, and run it again to assign a port or
                 another port.
  - -v /volumn :: create a mount at /volumn
  - -v /local/dir:/mnt :: mount local dir to the /mnt in
       container. The default is read-write mode, if you want read
       only, do this: =-v /local/dir:/mnt:ro=. The local dir must be
       ABSOLUTE path.
- docker exec <ID> echo "hello" :: run some command with arguments on the already run container <ID>
  - ID can be the UUID or container name
  - you can use -it as well, e.g. docker exec -it <ID> /bin/bash
- docker start <ID> :: start an already stopped container
- docker diff <ID> :: show the difference made from the base image
- docker commit <ID> lihebi/my-container :: create a new image based on the container <ID>
- docker login :: login so that you can push
- docker push lihebi/my-container :: push to docker hub
- docker pull lihebi/my-container :: pull from the internet

Alternatively, you can write a Dockerfile to specify how to build a image.

#+BEGIN_EXAMPLE
FROM ubuntu 15.04
RUN ech o"hello" > /tmp/newfile
#+END_EXAMPLE

In the folder containing Dockerfile, run to build the image:
#+BEGIN_EXAMPLE
docker build -t my-ubuntu .
#+END_EXAMPLE

use --no-cache to avoid using cache

- docker history <image> :: show which layers are used to create <image>

** Docker stop
docker stop will send SIGTERM to the app, then wait for it to stop. The default wait time is 10 seconds. You can change this by
#+BEGIN_EXAMPLE
docker stop -t 1 <container-ID>
#+END_EXAMPLE
This will change the timeout to be 1 second.

The reason for a container to resist stopping may be it ignores the
SIGTERM request. Python did this, so for a python program, you should
handle this signal yourself:
#+BEGIN_SRC python
  import sys
  import signal

  def handler(signum, frame):
      sys.exit(1)

  def main():
      signal.signal(signal.SIGTERM, hanlder)
      # your app
#+END_SRC


Next thing is the entry point and commands. If you use shell form, it
is started by sh -c, and shell will not pass the signal to the app
either. So change it to json form.

Finally, =docker stop= tries to terminate the app gracefully by
sending SIGTERM, you can choose to force kill using =docker kill=

* Remove sudo
#+BEGIN_EXAMPLE
sudo groupadd docker
sudo gpasswd -a ${USER} docker
sudo service docker restart
newgrp docker
#+END_EXAMPLE

* Dockerfile

I'm trying a docker file for srcml container. 
#+BEGIN_EXAMPLE
FROM debian
RUN apt-get -y update & apt-get install -y libarchive-dev libcurl4-openssl-dev
RUN wget http://131.123.42.38/lmcrs/beta/srcML-Ubuntu14.04-64.deb srcml.deb
RUN dpkg -i srcml.deb
#+END_EXAMPLE

** Commands
- FROM: a base image
- ENV key=value
- ADD: =ADD <src> .. <dst>= The difference from copy:
  - ADD allows src to be url
  - ADD will decompress an archive
- COPY: =COPY <src> .. <dst>= all srcs on the local machine will be
  copied to dst in the image. The src can use wildcards. The src
  cannot be out of the current build directory, e.g. =..= is not
  valid.
- USER: =USER daemon= The USER instruction sets the user name or UID
  to use when running the image and for any RUN, CMD and ENTRYPOINT
  instructions that follow it in the Dockerfile.
- WORKDIR: The WORKDIR instruction sets the working directory for any
  RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in
  the Dockerfile
  - if it does not exist, it will be created
  - it can be used multiple times, if it is relative, it is relative
    to the previous WORKDIR
- ENTRYPOINT ["executable", "param1", "param2"]: configure the
  container to be run as an executable.



* TODO Docker hub
When pushing and pulling, what exactly happens?

#+BEGIN_EXAMPLE
docker tag local-image lihebi/my-image
docker push lihebi/my-image
#+END_EXAMPLE

* Tricks
Stop all containers
#+BEGIN_QUOTE
docker stop $(docker ps -a -q)
#+END_QUOTE

Remove all containers (will not remove non-stopped ones, but give errors)
#+BEGIN_QUOTE
docker rm $(docker ps -a -q)
#+END_QUOTE


* Trouble Shooting
** I have to type double C-p to take effect
=C-p C-q= is the default binding for detaching a container. This
blocks C-p, I have to type it twice, must change.  In
=~/.docker/config.json=, add:

#+BEGIN_EXAMPLE
{
"detachKeys": "ctrl-],ctrl-["
}
#+END_EXAMPLE

Restart docker daemon to take effect. This can also be set by
=--detach-keys= option.


** Docker exec tty is not a real tty
I cannot connect to emacs server through emacsclient -t, and error
message is terminal is not found. You can not open tmux also. But the
problem does not appear when using docker run command.

The solution is when starting a exec command, use script to run bash:

#+BEGIN_EXAMPLE
docker exec -it my-container script -q -c "/bin/bash" /dev/null
docker exec -it my-container env TERM=xterm script -q -c "/bin/bash" /dev/null
#+END_EXAMPLE

The TERM is not necessary here because in my case docker always set it
to xterm. I actually change it to screen-256color in my bashrc file to
get the correct colors.
