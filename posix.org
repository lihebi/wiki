#+TITLE: POSIX


http://pubs.opengroup.org/onlinepubs/9699919799/


This page is based on POSIX.1-2008 2016 Edition



POSIX defines the operating system interface. The starndard contains volumes:
- Base Definition: convention, regular expression, headers
- System Interfaces: system calls
- Shell & Utilities: shell command language and shell utilities
- Rationale

I found most of them are not that interesting, except Base Definition
section 9 regular expression. This definition is used by many shell
utilities such as awk.


* Regular Expression
** Definition
The search for a matching starts at the beginning of string, and stops
when the /first/ sequence matching is found. If the pattern can match
several string at a start point, the /longest/ such sequence is
matched. In other word, /the longest of the leftmost matches/. 

Similarly Each subpattern (capturing group?), from left to right,
shall also match the longest possible string. E.g. when matching
=\(.*\).*=, the =(\1)= is the whole string.

The end of the string should be a NUL. Some utilities use <newline>.

** Basic Regular Expressions (BRE)
Special characters
- <period>, <left-square-bracket>, <baclslash>
  - when NOT in Bracket Expression
  - Match any character other than NUL
- <asterisk>
  - when NOT in Bracket Expression
  - when NOT the first of entire BRE (after initial =^= if any)
  - when NOT the first of subexpression (after initial =^= if any)
- circumflex>
  - when used as the first of the entire BRE
  - when used as the first in Bracket Expression
- <dollar-sign>
  - when used as the last of entire BRE
*** Bracket Expression
[^]...[:alnum:]..1-8.-]
- the close bracket can be ordinary if it is the first (after intial
  =^= is any)
- hyphen(-) can be ordinary if it is first of last. Put it last if you
  want to use it with close bracket above
- hyphen is inclusive
- =^= immediately after left bracket turns it into a non-matching
  list, a.k.a. matches any character except these.
- [:slnum:] is only valid inside bracket expression. It is called
  /character class expression/. All such expressions:
  - alnum, cntrl, lower, upper, space, alpha, digit
  - print, blank, graph, punct, xdigit

*** Matching Multiple Characters
- =*=
- =\(\)= is used. It can be arbitrarily nested. 
- =\N= is back reference. It shall match the same string as /was/
  matched by N-th sub-expression, it can be empty.
- =\{m\}=, =\{m,\}=, =\{m,n\}=: inclusive

*** Precedence
From high to low:
- =[::]=
- escape =\=
- bracket expression
- subexpression/back reference
- multiple character (=*= and =\{m,n\}=) (=+?= for ERE)
- concatenation
- anchor
- (=|= for ERE)


** Extended Regular Expressions (ERE)
- =()= are special
- =+?{= are special
- =|= is special

Note that no word begin in the standard.

* pThread

#+BEGIN_SRC cpp
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg)
pthread_exit (status)
pthread_join (threadid, status)
pthread_detach (threadid)
#+END_SRC

** Create threads
If main() finishes before the threads it has created, and exits with
pthread_exit(), the other threads will continue to execute. Otherwise,
they will be automatically terminated when main() finishes.

#+BEGIN_SRC cpp
  #define NUM_THREADS     5

  struct thread_data{
    int  thread_id;
    char *message;
  };

  int main() {
    pthread_t threads[NUM_THREADS];
    struct thread_data td[NUM_THREADS];

    int rc;
    int i;

    for( i=0; i < NUM_THREADS; i++ ){
      td[i].thread_id = i;
      td[i].message = "This is message";
      rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&td[i]);
      if (rc){
        cout << "Error:unable to create thread," << rc << endl;
        exit(-1);
      }
    }
    pthread_exit(NULL);
  }
#+END_SRC

** Join and Detach

#+BEGIN_SRC cpp
  int main () {
    int rc;
    int i;
	
    pthread_t threads[NUM_THREADS];
    pthread_attr_t attr;
    void *status;

    // Initialize and set thread joinable
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    for( i=0; i < NUM_THREADS; i++ ){
      cout << "main() : creating thread, " << i << endl;
      rc = pthread_create(&threads[i], &attr, wait, (void *)i );
		
      if (rc){
        cout << "Error:unable to create thread," << rc << endl;
        exit(-1);
      }
    }

    // free attribute and wait for the other threads
    pthread_attr_destroy(&attr);
	
    for( i=0; i < NUM_THREADS; i++ ){
      rc = pthread_join(threads[i], &status);
		
      if (rc){
        cout << "Error:unable to join," << rc << endl;
        exit(-1);
      }
		
      cout << "Main: completed thread id :" << i ;
      cout << "  exiting with status :" << status << endl;
    }

    cout << "Main: program exiting." << endl;
    pthread_exit(NULL);
  }
#+END_SRC

* std::thread
