#+TITLE: Clang

* Invoking

- =-ast-dump= :: dump ast
- =-ast-dump-filter= :: filter to only dump part of the AST
- =-ast-list= :: list ast nodes

#+BEGIN_EXAMPLE
clang -Xclang -ast-dump a.c
clang -emit-ast a.c
clang-check -ast-list lib/parser.cpp | grep AddValue
clang-check a.cc -ast-dump -ast-dump-filter=StdStringA --
#+END_EXAMPLE



* LibTooling

** Project Setup

*** Main File
First of all, get the =CMakeLists.txt= setup:

The first line:
#+BEGIN_SRC cmake
cmake_minimum_required(VERSION 3.0)
#+END_SRC

Setting directory to =lib= and =bin=

#+BEGIN_SRC cmake
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
#+END_SRC

Thread library:

#+BEGIN_SRC cmake
find_package (Threads)
link_libraries(${CMAKE_THREAD_LIBS_INIT})
#+END_SRC

LLVM library configuration:
#+BEGIN_SRC cmake
find_package(LLVM REQUIRED CONFIG)
message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMCOnfig.cmake in: ${LLVM_DIR}")
add_definitions(${LLVM_DEFINITIONS})
include_directories(${LLVM_INCLUDE_DIRS})
set(LLVM_LINK_COMPONENTS support)
#+END_SRC

Clang library setup
#+BEGIN_SRC cmake
find_package(Clang REQUIRED CONFIG)
#+END_SRC

Trouble shooting setup
#+BEGIN_SRC cmake
# Otherwise error: undefined reference to typeinfo for xxx
add_compile_options(-fno-rtti)
#+END_SRC

link library
#+BEGIN_SRC cmake
link_libraries(clang clangTooling clangFrontend clangFrontendTool)
link_libraries(libclang gtest)
#+END_SRC

Add sub-directories
#+BEGIN_SRC cmake
enable_testing()
add_subdirectory (src)
add_subdirectory (test)
#+END_SRC

*** Sub-directory files
=src/CMakeLists.txt= to add libraries, executables

#+BEGIN_SRC cmake
add_library (Sqr sqr.cpp sqr.h)
add_executable (demo main.cpp)
target_link_libraries (demo Sqr)

add_executable(ast ast.cpp)
add_executable(token token.cpp)
add_executable(rewriter rewriter.cpp)
#+END_SRC

=test/CMakeLists.txt=

The only requirement is to have =enable_testing= before =add_test=. The
command can be in =src= level list if no test source files.

#+BEGIN_SRC cmake
add_test(NAME toktest COMMAND hetok ../test/a.c)
add_test(NAME MyTest COMMAND Test)
#+END_SRC

** Header files
Some representative header files:

#+BEGIN_SRC cpp
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Frontend/FrontendActions.h"
#include "llvm/Support/CommandLine.h"
#include "clang/Tooling/CommonOptionsParser.h"
#+END_SRC

** Entry Point
The entry point is creating the =tooling::ClangTool= class.  Just pass
=argc/v= into it. The command line option =--= at the end to invoke the
tool will not trying to find compilation database.

#+BEGIN_SRC cpp
  int main(int argc, const char **argv) {
    CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);
    ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList());
    Tool.run(newFrontendActionFactory<MyAction>().get());
  }
#+END_SRC

The Tool would run on some "action". This is our main logic. The
action derives from =ASTFrontendAction=, and override the
=CreateASTConsumer= class.

#+BEGIN_SRC cpp
  class MyAction : public clang::ASTFrontendAction {
  public:
    virtual std::unique_ptr<clang::ASTConsumer>
    CreateASTConsumer(clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
      return std::unique_ptr<clang::ASTConsumer>
        (new MyConsumer(&Compiler.getASTContext()));
    }
  };
#+END_SRC

The Consumer would derive from =ASTConsumer= and override
=HandleTranslationUnit=. This function is called when the whole
translation unit is parsed. This provides the entry point of the AST
by the top most /decl/ by =Context.getTranslationUnitDecl()=.

The visitor will automatically call =WalkUpFromXXX(x)= to recursively
visit child nodes of x returning false of TraverseXXX or =WalkUpFromXXX=
will terminate the traversal. By default this will be a pre-order
traversal. Calling a method to change to post-order.

#+BEGIN_SRC cpp
  class MyConsumer : public clang::ASTConsumer {
  public:
    explicit MyConsumer(ASTContext *Context)
      : Visitor(Context) {}
    virtual void HandleTranslationUnit(clang::ASTContext &Context) {
      Visitor.TraverseDecl(Context.getTranslationUnitDecl());
    }
  private:
    MyVisitor Visitor;
  };
#+END_SRC

The visitor itself implement what to do with each AST node. Override
the list of =VisitXXX= method for each type of AST node.

#+BEGIN_SRC cpp
  class TokenVisitor
    : public RecursiveASTVisitor<TokenVisitor> {
  public:
    explicit TokenVisitor(ASTContext *Context)
      : Context(Context) {}
    bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {}
    bool VisitFunctionDecl(FunctionDecl *func_decl) {}
  private:
    ASTContext *Context;
  };
#+END_SRC


** Location
- Decl::getLocStart -> =SourceLocation= loc
- context->getFullLoc(loc) -> FullSourceLoc full
- full.getSpellingLinenumber

** APIs
=Decl=

#+BEGIN_SRC cpp
SourceLocation getLocStart ();
SourceLocation getLocEnd ();
virtual SourceRange getSourceRange ();
#+END_SRC

=ASTContext=

#+BEGIN_SRC cpp
FullSourceLoc getFullLoc (SourceLocation Loc) const
SourceManager& getSourceManager ()
#+END_SRC

=FullSourceLoc=

#+BEGIN_SRC cpp
unsigned getSpellingLineNumber (bool *Invalid=nullptr) const
unsigned getSpellingColumnNumber (bool *Invalid=nullptr) const
FileID 	getFileID () const
#+END_SRC

=SourceManager=

#+BEGIN_SRC cpp
FileManager& getFileManager () const;
FileID getMainFileID () const; // this file being processed
const FileEntry *getFileEntryForID (FileID FID) const;
#+END_SRC
