#+TITLE: sed

* usage
in shell script

#+begin_src shell
#!/bin/sed -f
#!/bin/sed -nf
#+end_src

* concepts
 * input
 * output
 * pattern space
 * hold space: This is a spare pattern space, used to remember the data in pattern buffer

* workflow
 * copy a line from input(exclude the tailing newline) into pattern buffer
 * apply command(s) to it
 * output

* cmd args
 * -n: by default each line of input is echoed to the standard output after all of the commands have been applied to it. The -n option suppresses this behavior
 * -e: sed -e 'xxx' -e 'xxx' -e 'xxx'
 * -f: script file

* range
sed will only apply command for the lines in the specified range.
If the command is preceded with =!=, that means the command works on lines not in the range.

#+begin_src shell
sed '1,100 s/A/a/' # by line number
sed '101,$ s/A/a/' # $ is last line
sed '/start/,/stop/ s/#.*//' # by pattern
#+end_src

* commands

** edit

| shortcut | name       | description |
|----------+------------+-------------|
| /        | <          | <           |
| a        | add        |             |
| i        | insert     |             |
| c        | change     |             |
| d        | delete     |             |
| s        | substitute |             |
|          |            |             |

** output

| shortcut | name  | description |
|----------+-------+-------------|
| /        | <     | <           |
| =        | print |             |
| l        | look  |             |
| p        | print |             |
| n        | next  |             |
| r        | read  |             |
| w        | write |             |

** flow control

| shortcut | name   | description |
|----------+--------+-------------|
| /        | <      | <           |
| q        | quit   |             |
| b        | branch |             |
| t        | test   |             |
| :label   |        |             |

* examples

print

#+begin_src shell
# add line numbers first,
# then use grep,
# then just print the number
cat -n file | grep 'PATTERN' | awk '{print $1}'
# the equilvalence
sed -n '/PATTERN/ =' file
#+end_src

substitute

#+begin_src shell
s/pattern/&/ # '&' stands for the total match
# in extend mode(-E), can use \1 \2
s/(a)b/\1/
s//string/ # use the last run-time used pattern
s/xxx/xxx/g # substitute globally: all
# there will not be recursion. sed will not examine the generated string
s/loop/loop loop/g # will NOT run forever
s/xxx/xxx/2 # only substitute the second match
s/xxx/xxx/g2 # substitute 2,3,4,...
s/xxx/xxx/p # will print out even if -n is used
s/xxx/xxx/I p # ignore case; command can be used together
s/a/A/2pw /tmp/file # combine more
#+end_src

delete

#+begin_src shell
# -i: make change to the original file
# /d: delete the line if match
sed -i '/@slice/d' $ClassName.java
sed -i 'g/@slice/d' xx.java # remove all
sed '/^$/d' # remove all empty lines
sed '11,$ d' # only output first 10 lines
sed '1,/^$/ d' # delete everything up to the first blank line.
#+end_src
