#+TITLE: COMS342 Recitation Oct 17 & 18
#+STARTUP: beamer
#+AUTHOR: Hebi Li
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+BEAMER-FRAME-LEVEL: 2
#+BEAMER_THEME: Madrid
#+OPTIONS: H:2 toc:nil num:t author:t
#+LATEX_HEADER: \lstset{numbers=none,frame=shadowbox, basicstyle=\scriptsize, breaklines=true, basewidth={0.45em,0.3em}, stringstyle=\ttfamily}

* Overview

** Outline
- quicksort algorithm in general
- The "instanceof" operator of java.
- higher order function advantage

** quicksort algorithm in general
#+BEGIN_EXAMPLE
quicksort(lst) {
  pivot = choose_pivot(lst);
  (first, second) = partition(pivot, lst);
  ret.append quicksort(first)
  ret.append quicksort(second)
}
partition(pivot, lst) {
  first = ()
  second = ()
  for (l in lst) {
    if (l < pivot) first.append(l)
    else second.append(l)
  }
}
#+END_EXAMPLE


** The "instanceof" operator of java.
Used to check whether a variable has a type of a class [fn:ins].

#+BEGIN_SRC java
  class A { }  
  class C extends A { } 
  class D extends A implements MyInterface { } 

  public static void testInstance(){
      A c = new C();
      A d = new D();
      Assert.assertTrue(c instanceof A && d instanceof A);
      Assert.assertTrue(c instanceof C && d instanceof D);
      Assert.assertFalse(c instanceof D);
      Assert.assertFalse(d instanceof C);
      Assert.assertFalse(c instanceof MyInterface);
      Assert.assertTrue(d instanceof MyInterface);
  }
#+END_SRC

[fn:ins] http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html

** higher order function advantage [fn:1]

| TITLE | ARTIST       | RATING | RIPPED |
|-------+--------------+--------+--------|
| Home  | Dixie Chicks |      9 | T      |
| Fly   | Dixie Chicks |      8 | T      |
| Roses | Kathy Mattea |      7 | T      | 

We want to define a SQL-like query language.
- select by title
- select by artist
- select by rating ..

[fn:1] http://www.gigamonkeys.com/book/practical-a-simple-database.html

** higher order function advantage (Ct.)

**** Ordinary solution (use a loop):
#+BEGIN_SRC lisp
  (defun select-by-artist (artist)
    (loop for cd in *db*
         (if (equal (getf cd : artist) artist)
             collect cd)))
#+END_SRC


** higher order function advantage (Ct.)

**** Better solution (mapping a function):
#+BEGIN_SRC lisp
  (defun select-by-artist (artist)
    (remove-if-not
     #'(lambda (cd) (equal (getf cd :artist) artist))
     ,*db*))
#+END_SRC

\pause

**** Even better (functions as selectors)
#+BEGIN_SRC lisp
  (defun select (selector-fn)
    (remove-if-not selector-fn *db*))

  (defun artist-selector (artist)
    #'(lambda (cd) (equal (getf cd :artist) artist)))
#+END_SRC

** higher order function advantage (Ct.)
*** Where clause:
#+BEGIN_SRC lisp
  (defun where (&key title artist rating (ripped nil ripped-p))
    #'(lambda (cd)
        (and
         (if title    (equal (getf cd :title)  title)  t)
         (if artist   (equal (getf cd :artist) artist) t)
         (if rating   (equal (getf cd :rating) rating) t)
         (if ripped-p (equal (getf cd :ripped) ripped) t))))
#+END_SRC

using by: =(select (where :rating 10 :ripped nil))=

\pause

*** *Ultimate Solution: Macro:*
#+BEGIN_SRC lisp
(defun make-comparison-expr (field value)
  `(equal (getf cd ,field) ,value))
(defun make-comparisons-list (fields)
  (loop while fields
     collecting (make-comparison-expr (pop fields) (pop fields))))
(defmacro where (&rest clauses)
  `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
#+END_SRC
