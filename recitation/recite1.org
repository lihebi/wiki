#+TITLE: COMS342 Recitation 1
#+STARTUP: beamer
#+AUTHOR: Hebi Li
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid
#+OPTIONS: H:2 toc:t num:t author:t
#+LATEX_HEADER: \lstset{numbers=none,frame=shadowbox, basicstyle=\scriptsize, breaklines=true, basewidth={0.45em,0.3em}, stringstyle=\ttfamily}

* Program Paradigm

# #+TOC: headlines [currentsection]

** Program Paradigm Overview
A programming paradigm is a style or “way” of programming. [fn:wiki-paradigm] [fn:ray-paradigm]

# - Some languages make it easy to write in some paradigms but not others.
# - A language can fall into multiple paradigms.
#   e.g. Most object oriented languages are also imperative languages.

# How the paradigm is determined
# - the execution model of the language
# - the way that code is organized
# - style of syntax and grammar


# languages that fit the declarative paradigm do not state the order in which to execute operations.
# Instead, they supply a number of operations that are available in the system, along with the conditions under which each is allowed to execute.

#+Caption: Paradigm
#+ATTR_LATEX: :font \scriptsize
| Program Paradigm | Description                    | Examples            |
|------------------+--------------------------------+---------------------|
| /                | <                              | <                   |
| Imperative       | First **do this then do that** | Fortran, C          |
| Declarative      | Describes **what to do**       | yacc, SQL, makefile |
|------------------+--------------------------------+---------------------|
| Functional       | **Side-Effect Free**           | Lisp, Scheme        |
| Object-Oriented  | simulate real-world objects    | C++, Java, Ruby     |
|------------------+--------------------------------+---------------------|
| Event-Driven     | OnDoingSometing()              | Android             |
| Logic            | Rules and queries              | Prolog              |

** imperative
Control flow is **explicit**. E.g. the following C code:

#+BEGIN_SRC C
  int main() {
    int i=0,sum=0;
    while (i<10) {
      if (i % 2 == 0) {
        sum = sum + i;
      } else {
        sum = sum + 2 * i;
      }
    }
  }
#+END_SRC

** Declarative
# The programmer states only what the result should look like, not how to obtain it.
# Express the logic of a computation without describing its control flow.
- Describes **what to do**, and *NOT* **how to do it**.
- Control flow is **implicit**.

This is a SQL query:
#+BEGIN_SRC sql
select upper(name)
from people
where length(name) > 5
order by name
#+END_SRC

** object orient
Send messages between objects, simulate real world interaction.

E.g. C++ code:
#+BEGIN_SRC C++
  class Rect {
  public:
    void SetHeight(int height) {m_height = height;}
    void SetWidth(int width) {m_width = width;}
    int GetArea() {return m_height * m_width;}
  private:
    int m_height = 0;
    int m_width = 0;
  };
  int main() {
    Rect rect;
    rect.SetHeight(5);
    rect.SetWidth(6);
    rect.GetArea(); // => 30
  }
#+END_SRC

** (pure) functional
- *Side-Effect free*: ~res=foo(a,b)~
- *Same input* produces *same output*
- Function as *First-class* citizen: e.g. parameter of function
  - =compute([1,2,3], sum)=
  - =compute([1,2,3], max)=
  - =compute([1,2,3], min)=
- Overtone (demo): http://overtone.github.io/

# Function is "first class" object.

# #+BEGIN_SRC lisp
#   ;; (defun do-the-math (x y z)
#   ;;   (+ x (* z (+ x y))))
# #+END_SRC



** event-driven
Android:

#+Caption: Android
#+ATTR_LATEX: :font \scriptsize
#+BEGIN_SRC java
  public class MainActivity extends Activity {
      public void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
      }
      protected void onStart() {
          super.onStart();
      }
      protected void onResume() {
          super.onResume();
      }
      protected void onPause() {
          super.onPause();
      }
      protected void onStop() {
          super.onStop();
      }
      public void onDestroy() {
          super.onDestroy();
      }
  }
#+END_SRC


** logic
- Components
  - Rules:  list the facts
  - Query
- Example: family tree

# #+BEGIN_EXAMPLE

#                            James I
#                               |
#                               |
#                 +-------------+-----------------+
#                 |                               |
#              Charles I                       Elizabeth
#                 |                               |
#                 |                               |
#      +----------+------------+                  |
#      |          |            |                  |
#  Catherine   Charles II   James II            Sophia
#                                                 |
#                                                 |
#                                                 |
#                                              George I
# #+END_EXAMPLE

# #+BEGIN_SRC dot :file wikitmp_family.png :exports results

#+BEGIN_SRC dot :file wikitmp_family.png :exports none
digraph {
James_I->Carles_I
James_I-> Elizabeth
Elizabeth -> Sophia
Sophia -> George
Carles_I -> Catherine
Carles_I -> Charles_II
Carles_I -> James_II
}
#+END_SRC

#+RESULTS:
[[file:wikitmp_family.png]]


#+ATTR_LATEX: :height .5\paperheight
[[file:wikitmp_family.png]]

** logic (prolog)

Rules: =parent(child, parent)=
#+BEGIN_SRC prolog
  parent(charles1, james1).
  parent(elizabeth, james1).
  parent(charles2, charles1).
  parent(catherine, charles1).
  parent(james2, charles1).
  parent(sophia, elizabeth).
  parent(george1, sophia).
#+END_SRC

Queries:
#+BEGIN_SRC prolog
  parent(charles1, george1) % => False
  parent(charles1,X) % => James1
  parent(X,charles1) % => catherine, chales2, james2
#+END_SRC

** Reverse A List
- C
#+BEGIN_SRC C
  void reverse(struct node **head) {
    struct node *prev = NULL;
    struct node *current = *head;
    struct node *next;
    while (current) {
      next = current->next;
      current->next = prev;
      prev = current;
      current = next;
    }
    ,*head = prev;
  }
#+END_SRC

** Reverse A List
- scheme
#+BEGIN_SRC scheme
  (define (rev lst)
    (if (null? lst)
        lst
        (append (rev (cdr lst))
                (list (car lst)))))
#+END_SRC
- prolog
#+BEGIN_SRC prolog
  rev([],[])
  rev(H|T,L) :-
      rev(T,T1),
      append(T1,[H],L)
#+END_SRC


* Language
# #+TOC: headlines [currentsection]

** Concepts
# terminals, non-terminals, production rules

# pumping lemma (https://en.wikipedia.org/wiki/Pumping_lemma)

- *set operation*: 
  - a set: $\{a,b\}$, $\{a|a \inB\}$
  - subset: $A \subset B$, $A \subseteq B$
  - interaction: $A \cup B$, $A \cap B$, $A \setminus B$
- *alphabet* are the set of atomic symbols
  - ={0,1,2,3,4,5,6,7,8,9}=
  - a,b,c,..
- A *word* is a *string* of alphabets
  - =1, 2, 12, 543, 1000, 002=
  - \alpha, \beta, ...
- All possible words form a *set* of words
  - {X,XX,XXX,...} for all X={0-9}
- A *language* is a subset of all the possible words
  - {1,3,5,7}
  - {1,3,5,7,...}
  - {1,11,111,...}

** Chomsky Hierarchy

- regular language
  - {42}
  - {prime number in range less than 100}
  - {string starting with double zeros}
- context-free language
  - $L = \{a^nb^n : n \ge 0\}$
- context-sensitive language
  - $L = \{ a^nb^nc^n : n \ge 0 \}$

#+ATTR_LATEX: :height .4\paperheight
[[./chomsky-hierarchy.svg.png]]

** Chomsky Hierarchy Grammar Rule
Preliminary:
- non-terminals: A,B,C
- terminals: a,b,c
- strings: a string of non-terminals and terminals: \alpha, \beta, \gamma
- production rule: $LHS \rightarrow RHS$

Languages:
- regular language: $A \rightarrow a$ or $A \rightarrow aB$
- context free: $A \rightarrow \gamma$
- context sensitive: $\alpha A\beta \rightarrow \alpha\gamma\beta$
- context free: $\alpha \rightarrow \beta$ (no restrictions)

** regular language - Informal Definition

#+BEGIN_QUOTE
Kleene's theorem: *regular expressions* is equivalent to *finite automata*
#+END_QUOTE

We call a language regular if:
- it can be decided if a word is in the language with a machine,
- with *constant (finite) memory*,
- by examining all symbols in the word one after another.

Alternatively:
- a regular language is recognized by a *finite automation*.

# The equivalence of  is known as  [fn:kleene].



** regular language - Example

Example:

- ={42}=:
  - Approach: check first, check second
- ={00XX}= where X is 0-9
  - Approach: check whether the first two are 0

# #+ATTR_LATEX: :width .5\linewidth
# #+BEGIN_SRC dot :file wikitmp_dot.png :exports results
#   digraph {
#     0->1[label="0"]
#     0->reject[label="other"]
#     1->accept[label="0"]
#     1->reject[label="other"]
#   }
# #+END_SRC

# #+RESULTS:
# [[file:wikitmp_dot.png]]

#+ATTR_LATEX: :height .5\paperheight
[[file:wikitmp_dot.png]]

# The regular expression: =00[0-9]*=

** Regular Language: Formal Definition
The collection of regular languages over an alphabet $\Sigma$ is defined recursively as follows:

- The empty language $\emptyset$, and the empty string language {$\Sigma$} are regular languages.
- For each $a \in \Sigma$ (a belongs to $\Sigma$), the singleton language {a} is a regular language.
- If A and B are regular languages, then $A \cup B$ (union), $AB$ (concatenation), and A* (Kleene star) are regular languages.
- No other languages over $\Sigma$ are regular.

** Pumping lemma for regular languages

# [fn:pump-regular]

Let L be a regular language.
Then there exists an integer $p \ge 1$ depending only on L such that every string w in L of length at least p (p is called the "pumping length")
can be written as w = xyz (i.e., w can be divided into three substrings), satisfying the following conditions:

1. $|y| \ge 1$
2. $|xy| \le p$
3. for all $i \ge 0$, $xy^iz \in L$

*Convert is not true*: a language that satisfies these conditions may still be non-regular.

** Example
the language $L = \{a^nb^n : n \ge 0\}$ over the alphabet $\Sigma = {a, b}$ is *non-regular*.

- For L there exists an integer p satisfying above lemma.
- For the word $w = a^pb^p$, it can be wrtten as $w = xyz$.
- Since $|xy| \le p$, y only consists of $a$.
- If we "pump" $y$, i.e. $xy^iz$, we keep adding "a" to the string, resulting in the number of $a$ is larger than the number of $b$, which is not in the language.

** context-free/sensitive language
- a context-free language (CFL) is a language generated by some context-free grammar (CFG) [fn:wiki-context-free]
- a context-sensitive language is a formal language that can be defined by a context-sensitive grammar [fn:wiki-context-sensitive]

** Pumping Lemma for context-free language

# [fn:pump-context]

If a language L is context-free, then there exists some integer $p \ge 1$ (called a "pumping length")
such that every string s in L that has a length of p or more symbols (i.e. with $|s| \ge p$) can be written as

- s = uvwxy

with substrings u, v, w, x and y, such that

1. $|vwx| \le p$
2. $|vx| \ge 1$, and
3. $uv^nwx^ny$ is in L for all $n \ge 0$. 

** Example
show language $L = \{ a^nb^nc^n | n > 0 \}$ is not context-free language.

- For L there exists an integer p satisfying above lemma.
- For the word $w = a^pb^pc^p$, it can be wrtten as $w = uvwxy$.
- Since $|vwx| \le p$, it can only consists of up to two distinct alphabets in $a,b,c$.
- If we "pump" $v$ and $x$, i.e. $uv^iwx^iy$, we keep adding two of them to the string, resulting in the lack of the third.


** Question
Questions?

[fn:kleene]: http://www.cs.may.ie/staff/jpower/Courses/Previous/parsing/node6.html
[fn:pump-context] https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages
[fn:wiki-context-free] https://en.wikipedia.org/wiki/Context-free_language
[fn:wiki-context-sensitive] https://en.wikipedia.org/wiki/Context-sensitive_language
[fn:pump-regular] https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages
[fn:wiki-paradigm] https://en.wikipedia.org/wiki/Programming_paradigm
[fn:ray-paradigm] http://cs.lmu.edu/~ray/notes/paradigms/
