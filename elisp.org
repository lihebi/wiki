#+TITLE: Emacs Lisp

#+BEGIN_QUOTE
The names CAR and CDR derive from the history of Lisp.  The original
Lisp implementation ran on an IBM 704 computer which divided words into
two parts, called the “address” part and the “decrement”; CAR was an
instruction to extract the contents of the address part of a register,
and CDR an instruction to extract the contents of the decrement.  By
contrast, “cons cells” are named for the function ‘cons’ that creates
them, which in turn was named for its purpose, the construction of
cells.
#+END_QUOTE
* Evaluation
The read and evaluate is /seperate/. For example, =(1 2 3)= is a list, and can be read by lisp interpreter as an object: a list.
But try to evalute it in emacs results in error. It is not because emacs cannot read it.
It can, but it try to evaluate it using a list form, which check the car of list and treat it as a function. Of course '1' is not a function.

There's a form called /self-evaluating form/. It evaluate to itself.

** quoting
From the elisp info page:
#+BEGIN_QUOTE
The special form ‘quote’ returns its single argument, as written,
without evaluating it.  This provides a way to include constant symbols
and lists, which are not self-evaluating objects, in a program.  (It is
not necessary to quote self-evaluating objects such as numbers, strings,
and vectors.)
#+END_QUOTE

The expression =\'print= means read it without evaluation. So the following expression makes sense:
#+BEGIN_SRC elisp
(eval (list 'prin1 '1))
#+END_SRC

Note that =(quote x)= and =\'x= are equivalent.

** backquoting
It is identical to quoting except that it allows to evaluate part of the object.
The special marker "," can be used:

#+BEGIN_SRC elisp
  `(a list of ,(+ 2 3) elements)
  ; -> (a list of 5 elements)
#+END_SRC

If the partial evaluation returns a list, but you want to *splice* it with some other elements into a list, you can do it neatly with ",@":

#+BEGIN_SRC elisp
  (setq some-list '(2 3))
  `(1 ,@some-list 4 ,@some-list)
  ;; -> (1 2 3 4 2 3)
#+END_SRC

Without this feature, you have to write some hard to understand code:
#+BEGIN_SRC elisp
  (cons 1 (append some-list '(4) some-list))
  ;; -> (1 2 3 4 2 3)
#+END_SRC


* Basic

- =(eq OBJ1 OBJ2)= :: Return t if the two args are the same Lisp object. It is faster than =equal=.
- =(equal O1 O2)= :: Return t if two Lisp objects have similar structure and contents. So it does /comparison only/.
- ~(=)~ :: true if all arguments are equal. Only works for numbers
- ~(string=)~ :: compare two strings

* Type
** number
- =(expt 2 8)= :: 2^8
** conversion
- string to int: =(values (parse-integer "32"))=
** cons cell
This is a pair of slots, each of them can hold anything.
A list is a list of cons cells, in which each cdr is the "address" next list.

A /dotted pair notation/ is a more general syntax of a cons cell.
It is written as =(A . B)=.
It is more general because the cdr can also hold anything.
As an example, =(1 2 3)= is the same as =(1 . (2 . (3 . nil)))=.

** list
If the CDR of a list’s last cons cell is some value other than ‘nil’,
we call the structure a "dotted list",
since its printed representation would use dotted pair notation.

*** construct
- =cons obj1 obj2= :: if obj2 is a list, this is called "cons obj1 onto the list"
- =(list &rest OBJECTS)= :: create a list
- =make-list length obj= :: make a list of length, in which each cell holds the /same/ object (=eq=)
- =(append &rest SEQUENCES)= :: concatenate some lists into one list.
  The last one is usually a list, all arguments except the last one are copied.
  If want to force copy everything, add a =nil= as the last of append.
- =(reverse '(1 2 3 4))= ::
- =number-sequence from to= :: the list of =[from,to]=, inclusive

*** access
- =car= ::
- =cdr= ::
- =car-safe= ::
- =cdr-safe= ::
- =pop= :: return the cdr of the list, and also remove it from the list
- =nth n list= :: get the nth element, starting from 0
- =nthcdr n list= ::
- =last list= ::
- =length= ::

- =caar= :: car car 11
- =card= :: car cdr 12
- =cdar= :: cdr car 21
- =cddr= :: cdr cdr 22

*** modify
/destructive/ means the cdr of the cons cells are modified.

- =push element listname= :: like cons it onto the list, but save it as listname, i.e. modify the variable
- =add-to-list symbol element= :: cons element onto the list if it is not there.
  So the following is equivalent: =(add-to-list 'var value)= and =(or (member value var) (setq var (cons value var)))=
- =setcar cons obj= ::
- =setcdr cons obj= ::
- =sort list predicate= :: this rearrange the cdrs of the list, so, /destructive/!
  Examples:
#+BEGIN_SRC elisp
(setq nums '(1 3 2 6 5 4 0))
(sort nums '<) ; accending
#+END_SRC

** set
We use list as set, by ignoring the order ...
=append= to combine two set, then =delete-dups= to remove duplication ...

- =memq obj list= :: whether obj is a member of list, using =eq=
- =delq obj list= :: destructively remove all elements =eq= to obj.
- =rmq obj list= :: return a copy of list with all obj removed
- =member= :: =equal= counter-part
- =member-ignore-case= :: for string
- =delete= :: =equal= counter-part
- =remove= :: =equal= counter-part
- =delete-dups= :: use =equal=
** association list
This is a special list, each element is a key-value pair.
#+BEGIN_SRC elisp
(setq alist-of-colors
  '((rose . red) (lily . white) (buttercup . yellow)))
#+END_SRC

- =assoc KEY aLIST= :: the first element of LIST whose car =equal= KEY.
- =rassoc value alist= :: compare the cdrs instead of cars
- =assq KEY aLIST= :: the first element of LIST whose car =eq= KEY.
- =rassq= :: =eq= counter-part

- =copy-alist alist= :: two-level deep copy
- =assq-delete-all key alist= :: delete all elements whose car =eq= key
- =rassq-delete-all value alist= :: cdr counter-part
- =(assoc-string KEY LIST &optional CASE-FOLD)= :: =assoc= for string. if =CASE-FOLD= is =non-nil=, case is ignored.

** property list
It is a flat list. The odd elements are property name, and the even elements are values.
#+BEGIN_SRC elisp
(pine cones numbers (1 2 3) color "blue")
#+END_SRC

It can be structured as

| property | value   |
|----------+---------|
| pine     | cones   |
| numbers  | (1 2 3) |
| color    | "blue"  |

The property names /must/ be unique.
The order of the "pairs" does not matter.

- =plist-get plist property= ::
- =plist-put plist property value= ::
- =lax-plist-get= :: =equal= counterpart
- =lax-plist-put= :: =equal= counterpart
- =plist-member plist property= :: this is useful because it can distinguish the missing property and the property with value "nil"

** array
It is fixed length sequence.
It contains:
- string
- vector
- char table
- bool vector

** sequence
#+BEGIN_EXAMPLE
               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

#+END_EXAMPLE

- =copy-sequence seq= :: the sequence is new, but the elements are not.

** hash table
construct
- =(make-hash-table)= ::

access
- =gethash key table= ::
- =puthash key value table= ::
- =remhash key table= :: remove
- =clrhash table= :: remove all
- =maphash function table= :: call function once for each of the element in table. The function should accept two arguments: key and value
other
- =hash-table-count table= :: return number of entries


* Symbol
- defvar
- defun
- defmacro

A symbol can /not/ be both a function and macro, but it can be a variable and a function at the same time.

** property list
A symbol can have a property list ...
- =get symbol property= ::
- =put symbol property value= ::
- =symbol-plist symbol= :: return the p-list
- =setplist symbol plist= ::
** Variable
Dynamic binding: in the defun, we can refer to free variable. When calling the defun in different environment, it will get the variable from them.
This is used by default.

#+BEGIN_SRC elisp
  (defvar x -99)
  (defun getx () x)
  (let ((x 1)) (getx)) ; -> 1
  (getx) ; -> -99
#+END_SRC

Lexical is also introduced as optional feature.

* Function
** Mapping family
- =(mapc FUNCTION SEQUENCE)=: Apply FUNCTION to each element of SEQUENCE.
- =(apply FUNCTION &rest ARGUMENTS)=: Call FUNCTION with our remaining args, using our /last arg/ as list of args.
  =(apply '+ 1 2 '(3 4))=



* Control Structure

** Sequential
- =progn forms...= :: return the result of final form
- =prog1 form1 forms...= :: return the result of form1
- =prog2 form1 form2 forms...= :: return the result of form2
** Conditional
- =if condition then-form else-forms...=
- =when condition then-forms...=
- =unless condition forms...=
- =cond clause...= :: the clause must be a list: =(condition body-forms...)=.
  It is not exactly the "case" statement, because the condition is evaluted to true or false.
  Any remaining forms are /ignored/.
- =pcase EXP BRANCH1 BRANCH2 BRANCH3...= :: this is more like the "case" statement. The EXP is first evaluted and compare with the car of each branches.
  The branch must be of the form =(UPATTERN BODY-FORMS...)=.

*** logical computation
- =not=
- =and=
- =or=

** Loop
- =while condition forms...=
- =dolist (var list [result]) body...= :: execute body for each element of list, with the bound of var to the current element and result for return.
- =dotimes (var count [result]) body...= :: execute body for each index of =[0,count)=, with var bound to the index, and result bound for return.

*** Overview
 The =cl-loop= refers to the common lisp, see the detailed manual in info, =cl=.
 #+BEGIN_SRC elisp
   (cl-loop for buf in (buffer-list)
            collect (buffer-file-name buf)) ; in the end the collected list will be returned
   (cl-loop repeat 20 do (insert "Yowsa\n")) ; repeat <num>
   (cl-loop until (eobp) do (munch-line) (forward-line 1)) ; eobp: end of buffer predicate
   (cl-loop do (munch-line) until (eobp) do (forward-line 1)) ;; do (much-line) at least once
 #+END_SRC
 Last, the if you want to nest the loop, you need multiple =cl-loop=.
 One cl-loop with multiple =for= and =until= will only result in one loop, e.g. the following code.

 #+BEGIN_SRC lisp
   (cl-loop for x from 1 to 100 ; x from 1 to 100
            for y = (* x x) ; this is evaluated for every iteration
            until (>= y 729) ; the end condition
            finally return (list x (= y 729))) ; finally defines what to do when the loop finish
 #+END_SRC

 Some other clauses are not recorded in this page, but there /are/ some. E.g.
 - =with VAR = VALUE=: bind the initial value,
   like the =EXPR1= in =for= clause,
   but different in terms of only evaluate once for the initial iteration.
   The effect is like =let=.
 - =if CONDITION CLAUSE=: execute the /following/ code only if the condition matches.
   =else= can be added, and =end= can also be presented. This means, this grammar is ambiguous.
*** For
**** for VAR from EXPR1 to EXPR2 by EXPR3
 #+BEGIN_SRC elisp
   (cl-loop for x to 10 collect x)
   ;; ⇒ (0 1 2 3 4 5 6 7 8 9 10)
   (cl-loop for x below 10 collect x)
   ;; ⇒ (0 1 2 3 4 5 6 7 8 9)
 #+END_SRC

**** for VAR in LIST by FUNCTION
 If the function is provided, the iterating function will be changed from the default =cdr=
 #+BEGIN_SRC elisp
   (cl-loop for x in '(1 2 3 4 5 6) collect (* x x))
   ;; ⇒ (1 4 9 16 25 36)
   (cl-loop for x in '(1 2 3 4 5 6) by 'cddr collect (* x x))
   ;; ⇒ (1 9 25)
 #+END_SRC
**** for VAR = EXPR1 then EXPR2
 If =EXPR2= is omitted, =EXPR1= will be set in each iteration.
 If =EXPR2= presents, =EXPR1= will only set the initial value, and =EXPR2= will execute and set the variable.
 =EXPR2= can refer to the previous value of =VAR=.
 #+BEGIN_SRC elisp
   ;; these two loops are equivalent
   (cl-loop for x on my-list by 'cddr do …)
   (cl-loop for x = my-list then (cddr x) while x do …)
 #+END_SRC

*** The condition
 - =repeat INTEGER=
 - =while CONDITION=
 - =until CONDITION=
 - =always CONDITION=: the condition should evaluate to t for it to continue
 - =never CONDITION=
 - =thereis CONDITION=
*** accumulation clause
 - =collect FORM=
 - =concat FORM=
 - =count FORM=
 - =sum FORM=
 - =maximize FORM=
 - =minimize FORM=



* Emacs Related
- =print= :: print the object in quotes, with a newline before and after it
- =prin1= :: print the object in quotes without newlines
- =princ= :: print the object without quotes, without newlines
- =message=
** Buffer related
- =with-temp-buffer=
  =(with-temp-buffer &rest BODY)= Create a temporary buffer, and evaluate BODY there like =progn=.

- =(insert-file-contents FILENAME &optional VISIT BEG END REPLACE)=: Insert contents of file FILENAME after point.
- =(secure-hash ALGORITHM OBJECT &optional START END BINARY)=: the object can be a buffer.
  This can be used to compare if a file has changed.
- =(current-buffer)=: Return the current buffer as a Lisp object.
- =(message FORMAT-STRING &rest ARGS)=: Display a message at the bottom of the screen.


** File System Related
*** Traversing
#+BEGIN_SRC elisp
(directory-files DIRECTORY &optional FULL MATCH NOSORT)
#+END_SRC

Return a list of names of files in DIRECTORY.

Usage example:
#+BEGIN_SRC elisp
(bib-files (directory-files bib-dir t ".*\.bib$"))
#+END_SRC

*** Predicates
=directory-files= will throw error if the directory does not exist.
So a safe way is to check if the directory exists first.
This predicate does this:
#+BEGIN_SRC elisp
(file-exists-p FILENAME)
#+END_SRC
Directory is also a file.

Other predicates includes:
#+BEGIN_EXAMPLE
file-readable-p
file-executable-p
file-writable-p
file-accessible-directory-p
#+END_EXAMPLE

** Other
- =(defalias SYMBOL DEFINITION &optional DOCSTRING)=: Set SYMBOL's function definition to DEFINITION.
  E.g. =(defalias 'helm-bibtex-get-value 'bibtex-completion-get-value)=,
  serves as a temporary patch for =helm-bibtex= update its API to =bibtex-completion=

*** make-obsolete-variable
=(make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN &optional ACCESS-TYPE)=

Make the byte-compiler warn that OBSOLETE-NAME is obsolete.

=helm-bibte= used it when it refactored the "helm" part off into a module,
to support different backend other than =helm=.
As a result, most =helm-bibtex-= prefixes are changed to =bibtex-completion-= ones.
But they want the end user's configuration will not break,
and at the same time warn them to update to the new name.
Here's the code, and the last line is what actually uses the function.
The actual effect is the user's configuration will be marked as warning,
the mini-buffer will describe the obsolete detail.

#+BEGIN_SRC elisp
  (cl-loop
   for var in '("bibliography" "library-path" "pdf-open-function"
                "pdf-symbol" "format-citation-functions" "notes-path"
                "notes-template-multiple-files"
                "notes-template-one-file" "notes-key-pattern"
                "notes-extension" "notes-symbol" "fallback-options"
                "browser-function" "additional-search-fields"
                "no-export-fields" "cite-commands"
                "cite-default-command"
                "cite-prompt-for-optional-arguments"
                "cite-default-as-initial-input" "pdf-field")
   for oldvar = (intern (concat "helm-bibtex-" var))
   for newvar = (intern (concat "bibtex-completion-" var))
   do
   (defvaralias newvar oldvar)
   (make-obsolete-variable oldvar newvar "2016-03-20"))
#+END_SRC


* Packages
** Dash.el
 https://github.com/magnars/dash.el

 This is a collection of list libraries.

- =-map= takes a function to map over the list,
 the anaphoric form with double dashes executed with =it= exposed as the list item. 
 #+BEGIN_SRC elisp
 ;; normal version
 (-map (lambda (n) (* n n)) '(1 2 3 4))
 ;; also works for defun, of course
 (defun square (n) (* n n))
 (-map 'square '(1 2 3 4))
 ;; anaphoric version
 (--map (* it it) '(1 2 3 4))
 #+END_SRC

- =-update-at=: =(-update-at N FUNC LIST)= Return a list with element at Nth position in LIST replaced with `(func (nth n list))`.
- =-flatten=: =(-flatten L)=: Take a nested list L and return its contents as a single, flat list.

** s.el
 https://github.com/magnars/s.el

 The string manipulation library

* Some random code snippets


#+begin_src elisp
(cl-prettyprint (font-family-list)) ;; see all font family available on this system
#+end_src

*** Url retrieval
#+BEGIN_SRC elisp
  (with-current-buffer (url-retrieve-synchronously "http://scholar.google.com/scholar?q=segmented symbolic analysis")
    (goto-char (point-min))
    (kill-ring-save (point-min) (point-max))
    )
  (let ((framed-url (match-string 1)))
    (with-current-buffer (url-retrieve-synchronously framed-url)
      (goto-char (point-min))
      (when (re-search-forward "<frame src=\"\\(http[[:ascii:]]*?\\)\"")
        (match-string 1))))
#+END_SRC

