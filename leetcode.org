#+TITLE: Leetcode

* General Tips
#+BEGIN_SRC C
#include <climits>
int res = INT_MIN;
if (tmp > res) res = tmp;
#+END_SRC


- lower_bound: larger or greater than
- upper_bound: strictly larger than

To get a smaller iterator, use =upper_bound= and decrease it (after check if it is begin)

#+BEGIN_SRC C++
  auto pre_it = m_data.upper_bound(val);
  auto next_it = pre_it;
  int pre_low, pre_high;
  int next_low, next_high;
  if (pre_it == m_data.end()) {
    next_low = INT_MAX;
    next_high = INT_MAX;
   } else {
    next_low = next_it->first;
    next_high = next_it->second;
   }
  if (pre_it == m_data.begin()) {
    pre_low = INT_MIN;
    pre_high = INT_MIN;
   } else {
    pre_it--;
    pre_low = pre_it->first;
    pre_high = pre_it->second;
   }
#+END_SRC

** GCD
- swap
- make sure x,y are POSITIVE
- When divide it, make sure it is not 0!
#+BEGIN_SRC C++
  int GCD(int x, int y) {
    if (x > y) std::swap(x,y);
    if (x == 0) return y;
    return GCD(y%x, x);
  }
#+END_SRC

* Famous Problems and Algorithms

** Maximum subarray problem and Kadane's algorithm

Problem: finding the contiguous subarray within a one-dimensional array of numbers which has the largest sum

Kadane's algorithm:
#+BEGIN_SRC python
def max_subarray(A):
    max_ending_here = max_so_far = 0
    for x in A:
        max_ending_here = max(0, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
#+END_SRC

or if 0 is not a predefined return value:
#+BEGIN_SRC python
def max_subarray(A):
    max_ending_here = max_so_far = A[0]
    for x in A[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
#+END_SRC

** longest increasing sub-sequence(LIS)
Find the longest increasing sub-sequence.
=O(n^2)=
#+BEGIN_SRC C++
  int sol_nn(vector<int> &nums) {
    if (nums.size() == 0) return 0;
    if (nums.size() == 1) return 1;
    vector<int> dp(nums.size(), 1);
    int size = nums.size();
    for (int i=1;i<size;i++) {
      for (int j=0;j<i;j++) {
        if (nums[i] > nums[j]) {
          dp[i] = std::max(dp[i], dp[j] + 1);
        }
      }
    }
    int ret = 1;
    for (int i=0;i<size;i++) {
      ret = std::max(ret, dp[i]);
    }
    return ret;
  }
#+END_SRC

=O(nlog(n))=
#+BEGIN_SRC C++
  int sol_nlogn(vector<int> &nums) {
    if (nums.empty()) return 0;
    vector<int> list;
    for (int num : nums) {
      auto it = lower_bound(list.begin(), list.end(), num);
      if (it == list.end()) {
        list.push_back(num);
      } else {
        *it = num;
      }
    }
    return list.size();
  }
#+END_SRC


** Dynamic Programming
Solving a complex problem by breaking it down into a collection of simpler subproblems,
solving each of those subproblems just once, and storing their solutions
- ideally, using a memory-based data structure.

There're generally just two ways for DP:
- bottom up: solve sub problem, and represent bigger problem
- top down: represent bigger problem by sub problems

*** Apply to LIS
The length of the LIS ending in the current element is the length of the LIS ending in the smaller one + 1.


** Patience sorting
*** The sort algorithm
The algorithm derives from  patience card game.

This game begins with a shuffled deck of cards. These cards are dealt one by one into a sequence of piles on the table, according to the following rules.
- Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.
- Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or equal the new card's value, or to the right of all of the existing piles, thus forming a new pile.
- When there are no more cards remaining to deal, the game ends.

clearly the complexity is =O(nlogn)=.

*** Apply to LIS problem
First, execute the sorting algorithm as described above.
The number of piles is the length of a longest subsequence.
Whenever a card is placed on top of a pile,
put a back-pointer to the top card in the previous pile (that, by assumption, has a lower value than the new card has).
In the end, follow the back-pointers from the top card in the last pile to recover a decreasing subsequence of the longest length;
its reverse is an answer to the longest increasing subsequence algorithm.

*** LIS problem another understanding
Keep a set of active lists for the longest.
Actually use the reversed pile of Patience sorting.
Whenever add a number to a pile, remove all other piles with the same length.
This should save a lot of computing!

e.g. 58364129
#+BEGIN_EXAMPLE
58 ---
36 ---
4 ---
129
#+END_EXAMPLE

*end element of smaller list is smaller than end elements of larger lists.*

* Problems

** 363. Max Sum of Rectangle No Larger Than K
- If we want to switch row and column of a matrix if col is larger than row, simply
  1. use a boolean flag
  2. swap the row and column size variable.
  3. when accessing data, swap the row and column, e.g. =data[col][row]= instead of =data[row][col]=
- =std::swap=, =std::max=
- In this problem, the reused computation is not whole, but partial: only column (or row) part computation is reused.
  Thus the problem matters for each one is larger.
- A very interesting point is, the =temp[]= vector keep tracking the sum of current row, while =sum= keeps the sum of rows.
- =sums= keep the sums of the rows, and use lower_bound feature of std::set for =sums.lower_bound(sum - k)=


#+BEGIN_SRC C++
  int maxSumSubmatrix(vector<vector<int> >& matrix, int k) {
    if (matrix.size() == 0) return 0;
    int row = matrix.size();
    int col = matrix[0].size();
    bool row_large = true;
    if (row > col) {
      row_large = true;
    } else {
      row_large = false;
      std::swap(row, col);
    }
    int ret = INT_MIN;

    for (int c=0;c<col;c++) {
      vector<int> temp(row, 0);
      // sums.insert(0);
      for (int i=c;i>=0;i--) {
        int sum = 0;
        set<int> sums;
        sums.insert(0);
        for (int r=0;r<row;r++) {
          temp[r] += row_large ? matrix[r][i] : matrix[i][r];
          sum += temp[r];
          auto it = sums.lower_bound(sum - k);
          if (it != sums.end()) {
            int res = sum - *it;
            ret = std::max(ret, res);
          }
          sums.insert(sum);
        }
      }
    }
    return ret;
  }
#+END_SRC



** 65. valid number
#+BEGIN_EXAMPLE
  EXPECT_TRUE(s.isNumber("+.8"));
  EXPECT_TRUE(s.isNumber(".1"));
  EXPECT_TRUE(s.isNumber("-5.3"));

  EXPECT_FALSE(s.isNumber(". 1"));
  EXPECT_FALSE(s.isNumber("4e+"));
  EXPECT_FALSE(s.isNumber("6e6.5"));
#+END_EXAMPLE
