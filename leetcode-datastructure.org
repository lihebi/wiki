#+TITLE: LeetCode Used Data Structure


** Trie

*** 79. Word Search I

Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring.
The same letter cell may not be used more than once.

No magic here, try to start from each cell.
Recur the four directions, so that the back-tracing is automatic by recurrence.

#+BEGIN_SRC C++
class Solution {
public:
  bool exist(vector<vector<char>>& board, string word) {
    if (board.empty() || board[0].empty()) return false;
    for (size_t i=0;i<board.size();i++) {
      for (size_t j=0;j<board[0].size();j++) {
        if (recur(board, word, i, j, 0)) return true;
      }
    }
    return false;
  }
  bool recur(vector<vector<char>> &board, string word, int x, int y, int idx) {
    // std::cout << "recur: " << x << "," << y  << "\n";
    if (idx >= (int)word.size()) {
      return true;
    }
    if (x < 0 || y < 0 || x >= (int)board.size() || y >= (int)board[0].size()) {
      // std::cout << "  <--"  << "\n";
      return false;
    }
    if (board[x][y] != word[idx]) {
      // std::cout << "  <--"  << "\n";
      return false;
    }
    if (board[x][y] == word[idx]) {
      char c = board[x][y];
      board[x][y] = '\0';
      if (
          recur(board, word, x+1, y, idx+1)
          || recur(board, word, x, y+1, idx+1)
          || recur(board, word, x-1, y, idx+1)
          || recur(board, word, x, y-1, idx+1)
          ) return true;
      board[x][y] = c;
      return false;
    }
    return false;
  }
};
#+END_SRC

*** Trie
The implementation is easy, but know when to use it is hard!
#+BEGIN_SRC C++
class TrieNode {
public:
  TrieNode() {
  }
  TrieNode *child(char c) {
    if (m_map.count(c) == 1) return m_map[c];
    return NULL;
  }
  TrieNode *addChild(char c) {
    TrieNode *node = new TrieNode();
    m_map[c] = node;
    return node;
  }
  bool isLeaf() {
    return m_isleaf;
  }
  void setLeaf() {
    m_isleaf = true;
  }
  bool hasChild() {
    return !m_map.empty();
  }

private:
  std::map<char, TrieNode*> m_map;
  bool m_isleaf = false;
};

class Trie {
public:
  Trie() {
    root = new TrieNode();
  }

  // Inserts a word into the trie.
  void insert(string word) {
    TrieNode *node = root;
    for (char c : word) {
      if (node->child(c)) {
        node = node->child(c);
      } else {
        node = node->addChild(c);
      }
    }
    node->setLeaf();
  }

  // Returns if the word is in the trie.
  bool search(string word) {
    TrieNode *node = root;
    for (char c : word) {
      if ((node = node->child(c))) {
      } else {
        return false;
      }
    }
    if (node->isLeaf()) {
      return true;
    }
    return false;
  }

  // Returns if there is any word in the trie
  // that starts with the given prefix.
  bool startsWith(string prefix) {
    TrieNode *node = root;
    for (char c : prefix) {
      if ((node = node->child(c))) {
      } else {
        return false;
      }
    }
    return true;
  }

private:
  TrieNode* root;
};
#+END_SRC

*** 212. Word Search II

We only carry the TrieNode, and it should store the word, aka the value.
#+BEGIN_SRC C++
class Solution {
public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    // construct a trie for all the words to search
    // continue to do the recursive method
    // keep the track of current value
    // if cannot search it on trie, stop the recursion along this line
    Trie trie;
    for (string s : words) {
      trie.insert(s);
    }
    for (int i=0;i<(int)board.size();i++) {
      for (int j=0;j<(int)board[0].size();j++) {
        recur(board, i, j, trie.getRoot());
      }
    }
    vector<string> retv (ret.begin(), ret.end());
    return retv;
  }
  void recur(vector<vector<char> > &board, int i, int j, TrieNode *node) {
    if (!node) {return;}
    if (node->isLeaf()) ret.insert(node->Value());
    if (!node->hasChild()) {return;}
    if (i < 0 || j < 0 || i >= (int)board.size() || j >= (int)board[0].size()) {return;}
    if (node->child(board[i][j])) {
      char c = board[i][j];
      board[i][j] = '\0';
      node = node->child(c);
      recur(board, i, j-1, node);
      recur(board, i, j+1, node);
      recur(board, i-1, j, node);
      recur(board, i+1, j, node);
      board[i][j] = c;
    } else {
      return;
    }
  }
private:
  set<string> ret;
};
#+END_SRC


