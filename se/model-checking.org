#+TITLE: Model Checking

Model checking cite:2004-Book-Huth-Logic is based on /temporal
logic/. Models M are transition systems, and properties $\phi$ are
formulas in temporal logic. /Model checking/ is the process of
computing an answer to the question whether $M,s \models \phi$ holds.

The model is typically modeled as /Kripke Structure (KS)/.
1. S: set of states
2. T: transitions: $\subset SxS$
   - /left total/: forall s, exists s', s,s' \in T. I.e. every state
     has an outgoing edge.
3. L: labeling function, e.g. busy, non-busy. S->P(AP): P: powerset,
   AP: set of propositions

There are two types of temporal logic, the Linear-time Temporal Logic
(LTL) and Computation Tree Logic (CTL).

* Linear-time Temporal Logic
LTL has the basic operations, including $\neg$, $\wedge$, $\vee$,
$\rightarrow$. In addition, it has /temporal connectives/ X (next), F
(future), G (globally), U (until), W (weak-until), R (release).
Operators have priority and associativity.
- unary bind most tightly, including $\neg$, X, F, G
- U, R, W
- $\wedge$ and $\vee$
- Lastly, the $\rightarrow$

A path $\pi$ in LTL is an *infinite* sequence of states (starting from
the initial state?). The suffix $\pi^3$ means dropping the path first
two states.

The semantic of LTL formulas:
- Basic:
  - $\pi \models \top$: true
  - $\pi \models \bot$: false
  - $\pi \models p$ iff $p \in L(s_1)$
- Simple operators including $\neg$, $\wedge$, $\vee$ have intuitive
  semantics
- $\pi \models \phi_1 \rightarrow \phi_2$ iff $\pi \models \phi_2$
  whenever $\pi \models \phi_1$. +In other words, $\pi \models
  \phi_1$, otherwise $\pi \models \phi_2$+. *This is very different
  from CTL arrows*.
- Simple connectives including X,G,F have intuitive semantics
- $\pi \models \phi U \psi$ iff *$\phi$ holds until some point, $\psi$
  holds*
- $\pi \models \phi W \psi$: the weak until is closely related to
  until. It contains the semantic of until, but also *allow $\phi$ to
  hold in all states*. So something like $W = U \vee G$
- $\pi \models \phi R \psi$: this is similar (but not dual) to weak
  until: it says *$\psi$ holds until some point, $\phi$ holds*. Or,
  $\psi$ holds all the time.

In temporal logic, future starts from right now.

Putting the LTL formula into model checking problem, we have that,
$M,s \models \phi$ iff for *every* execution path $\pi \models \phi$.

LTL formulas $\phi$ and $\psi$ are equivalent, written as $\phi \equiv
\psi$, iff both hold or not hold for *all* models. We have several
equivalent classes:
- $\neg (\phi \wedge \psi) \equiv \neg \phi \vee \neg \psi$
- *F and G are dual of each other*: $\neg G \phi \equiv F \neg \phi$
- *X is dual of itself*: $\neg X \phi \equiv X \neg \phi$
- *U and R are dual of each other*: $\neg (\phi U \psi) \equiv \neg \phi
  R \neg \psi$
- *F distributes over $\vee$, G distributes over $\wedge$*: $F(\phi \vee
  \psi) \equiv F\phi \vee F\psi$
- Actually F and G can be expressed by U and R: $F\phi \equiv \top U
  \phi$, $G\phi \equiv \bot R \phi$
- The relation of strong and weak until, as we stated informally
  before, can be expressed as equivalent class as well:
  - $\phi U \psi \equiv \phi W \psi \wedge F \psi$
  - $\phi W \psi \equiv \phi U \psi \vee G \phi$
- Lastly, W and R are similar to each other, thus, we can express
  - $\phi W \psi \equiv \psi R (\phi \vee \psi)$
  - $\phi R \psi \equiv \psi W (\phi \wedge \psi)$

Since many of the connectives are equivalent, the question is, what is
the adequate set of connectives? Here is the conclusion:
- X is completely orthogonal, thus X must be in
- Actually, any one of U,R,W (actually should also includes G,F) can
  be used to get others, simply look at the equivalent classes and the
  dual relationships.
- We are assuming free use of negation. One useful thought is the
  adequate set without using negation.

* Computation Tree Logic

In the model context, LTL implicitly *quantifies universally* over all
paths. Thus, we can only specify whether a property is satisfied on
all path, or on one path (by checking the negation of the property),
but cannot express the mix of universal and existential path, because
*the complement formula still has a mix*. Thus, we need CTL.

The /Computation model/ pick a state, and unfold (infinite because of
left total) all transitions. It is a tree. Thus it is also called
/computation tree model/.

A /path/ is a ordered sequence of states in the computation model
(also infinite).

The connectives are different from those of LTL, where there are
X,F,G,U,W,R. The counter parts in CTL always have a A (always) or E
(exists) prefix, so:
- AX,EX
- AF,EF
- AG,EG
- AU, EU
- We don't model W and R here

The priority is similar to those of LTL.

The semantic of CTL is encoded like this. Note that instead of a path,
we are modeling the whole model, i.e. all path.
- Basic
  - $M,s \models \top: always true
  - $M,s \models \bot$: false
  - $M,s \models p$ iff $p \in L(s)$
- Simple connectives including X,G,F have intuitive semantics
- $M,s \models \phi_1 \rightarrow \phi_2$ iff $M,s \models \phi_1$ or
  $M,s \models \phi_2$. Note: this seems to be exactly the same as
  $M,s \models \phi_1 \vee \phi_2$, and is substantially different
  from that of LTL.
- Other connectives have intuitive semantics

Two CTL formula are equivalent if they have same value in *any state
in any model*. Similar to LTL:
- AF and EG are dual: $\neg AF \phi \equiv EG \neg \phi$
- EF and AG are dual: $\neg EF \phi \equiv AG \neg \phi$
- AX and EX are dual: $\neg AX \phi \equiv EX \neg \phi$
- F can still be expressed by U, no matter AF or EF:
  - $AF \phi \equiv A (\top U \phi)$
  - $EF \phi \equiv E (\top U \phi)$

According to the above equivalent classes, we can easily find the
adequate set:
- one of AX,EX
- one of EG, AF, AU
- EU (shouldn't this be one of EU,EF?)


* Ordered Binary Decision Diagram (OBDD)

A boolean function of n arguments is a function from $\{0,1\}^n$ to
$\{0,1\}$. Such boolean functions can be modeled intuitively by truth
table, but is space-inefficient. The propositional formulas are
better, but still hard to decide equivalence (require exponential
time).

/Binary Decision Diagram (BDD)/ is a way to represent boolean
functions. It is a /Directed Acyclic Graph (DAG)/. A node is called
terminal if it has no outgoing edges. All other nodes are terminal
node. In BDD, all terminal nodes are labeled either 0 or 1. All
non-terminal nodes are labeled by a variable. Each variable node $x$
has two outgoing edges, one dashed taken when $x=0$, one solid taken
when $x=1$.

We need to reduce BDD to as simple as possible. There are three kinds
of reductions. A BDD is called /reduced/ if optimization C1-C3 cannot
be performed.
- C1: there should be exactly one 0 and 1
- C2: if both outgoing edges goes to the same node, this node should
  be removed.
- C3: if two nodes have identical subBDDs (defined as the part of BDD
  below a given node), they should be merged into one.

We say a BDD has an ordering of variable $x_1,...,x_n$ if along all
path, this order is not violated. When operations are performed on two
OBDDs, we usually require they to have /compatible variable ordering/,
i.e. the order should not conflict with each other. In general, the
ordering is very important in terms of the size of OBDD. But the book
does not mention what are the heuristics to decide the ordering.

We have the theorem that, the reduced OBDD of a function is unique (I
think given the ordering, i.e. from the original OBDD). It also means
that, if we apply the reductions C1-C3 to an OBDD until reduced, the
results are always the same, no matter what order we applied the
reduction. This is called the /canonical form/ of the OBDD.

The algorithm reduce works like this:
- Initially, assign label #0 to terminal 0, #1 to terminal 1
- From bottom to up, check
  - C2: if the node's outgoing edge points to the same label, assign
    it that label, i.e. remove it.
  - C3: if there is another node that is already labeled, and this
    node has the same two outgoing structure, use that label
  - Otherwise, assign a new label

There seems to have another algorithm apply that compose two OBDDs.



* NuSMV
** Language
A SMV model is specified by several modules, like functions. There
must be one module named =main= without formals, and is executed by
the interpreter.

Module can takes formals, which are call-by-reference when
instantiates with actual parameters. A module must be instantiated, in
VAR declaration, to be reused. It is through using the module inside
the type of variable. An optional =process= can be used here to
specify asynchronous behavior. This is deprecated, and modeling of
asynchronous will have to be resolved at a higher level. You can
reference the components using dot notation, and the variable support
very permissive forward declaration, you can use arbitrary dot
notation as long as it is valid by some declaration in some time.

Each module has several variable and defines. Variables are states. It
is declared with its type, like
- =boolean=
- =1..5=: integers must be ranged
- =array 2..5 of boolean=: array must be defined with the subscription
  range as well as inside type
- signed/unsigned word[3]: vector of bits (booleans).

However, defines are macros, substituted when appear in
expression. Thus it is real time, and can also refer to next
expression in its definition.

Each module also has a =ASSIGN= block for specifying changes. It can
be either a =init= or =next= expression. Inside the assignment, the
RHS will be either a value, or a set, which means LHS can be EITHER
ONE inside the set. =next= cannot be nested, but next can be applied
to an expression, which is syntax sugar for apply next for each
variables inside the expression.

Besides =case=, tenary operator =cond?expr:expr= can be used for
simple conditions.

FAIRNESS is used to restrict attention only to good execution paths,
i.e. the good execution paths must be available in the future
/infinitely often/.

Finally, a SPEC can be given, using !, ->, &, |, EG, EX, EF, AG, AX,
AF, EU, AU, etc.

** Interactive Run
Run interactively by =NuSMV -int=. The following commands are
available.

*** General
- help
- history
- quit
- reset
- set [name] [value]
- source <file>: execute sequences of commands from a file, separated
  by semi-colon.

*** Reading models
- read_model -i [model-file]
- show_vars: show variables and defines
- write_order -o [order-file]
- build_model
- go: equivalent to read_model, flatten_hierarchy, encode_variables,
  build_flat_model, build_model
- process_model -i [model-file]: build model and check SPEC

*** Model checking
- compute_reachable
- print_reachable_states
- check_fsm
- check_ctlspec -p "ctl-expr [IN context]"
- check_ltlspec -p "ltl-expr [IN context]"

- pick_state -i: interactively pick initial state
- simulate
- execute_traces
- goto_state
- print_current_state
- show_traces

* Spin

Running of spin.

According to the [[http://spinroot.com/spin/Man/Spin.html][man page of
spin]], running =spin xxx.pml= will run a random simulation of the
model. 
- Running options: Given =-n<number>= will set a seed,
  i.e. deterministic run. =-i= can run interactively, select choice to
  take.
- Printing options: =-c= print out graphical results. =-g= show global
  variable at each time step. =-s= and =-r= prints the send and
  receive messages. They are also included in the =-c= option.
- =-run= will generate, compile and run the verifier, and check the
  LTL formula.

[[http://spinroot.com/spin/Man/promela.html][The reference page]].
