#+TITLE: Artificial Intelligence

* Adversarial Search

This is multiple agents, also known as /game/.

** Minimax Algorithm
There're two players, Min and Max, each takes turn to execute.
Max moves first.

*** The optimal strategies

#+BEGIN_LaTeX
\begin{equation*}
  MINIMAX-VALUE(n) = \left\{
  \begin{array}{r1}
    Utility(n) & \text {if n is terminal},\\
    max_{s \in succ(n)} MINIMAX-VALUE(s) & \text{if n is a max node},\\
    min_{s \in succ(n)} MINIMAX-VALUE(s) & \text{if n is a min node}.
  \end{array} \right .
\end{equation*}
#+END_LaTeX

Basically it recursively solve the problem.
The Utility function is the payoff.
It actually list the tree of state space, and it is optimal.

** Alpha-Beta pruning
The problem of minimax algorithm is its node grow exponential.
This algorithm is used to prune the subtree that does not affect the result.

This is similar for MiniMax algorithm
- \alpha is the value of the best choise so far, for max, init from -\infty
- \beta is the best value for min, init from +\infty

There're two procedures:
- =Alpha-Beta-Search(state)= :: returns an action. state is the current state.
- =Max-Value(state, \alpha, \beta)= :: returns a utility value
- =Min-Value(state, \alpha, \beta)= :: returns a utility value

#+BEGIN_EXAMPLE
Alpha-Beta-Search(state) {
  v = Max-Value(state, -999, +999);
  return action in ACTIONS with value v;
}

Max-Value(state, alpha, beta) {
  v = INT_MIN;
  for each a in ACTIONS(state) do
    v = Max(v, Min-Value(result(s,a), alpha, beta));
    if v >= beta then return v;
    alpha = MAX(alpha,v);
  return v;
}
#+END_EXAMPLE
