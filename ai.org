#+TITLE: Artificial Intelligence

* Adversarial Search

  This is multiple agents, also known as /game/.

** Minimax Algorithm
   There're two players, Min and Max, each takes turn to execute.
   Max moves first.

*** The optimal strategies

    #+BEGIN_LaTeX
\begin{equation*}
  MINIMAX-VALUE(n) = \left\{
  \begin{array}{r1}
    Utility(n) & \text {if n is terminal},\\
    max_{s \in succ(n)} MINIMAX-VALUE(s) & \text{if n is a max node},\\
    min_{s \in succ(n)} MINIMAX-VALUE(s) & \text{if n is a min node}.
  \end{array} \right .
\end{equation*}
    #+END_LaTeX

    Basically it recursively solve the problem.
    The Utility function is the payoff.
    It actually list the tree of state space, and it is optimal.

** Alpha-Beta pruning
   The problem of minimax algorithm is its node grow exponential.
   This algorithm is used to prune the subtree that does not affect the result.

   This is similar for MiniMax algorithm
   - \alpha is the value of the best choise so far, for max, init from -\infty
   - \beta is the best value for min, init from +\infty

   There're two procedures:
   - =Alpha-Beta-Search(state)= :: returns an action. state is the current state.
   - =Max-Value(state, \alpha, \beta)= :: returns a utility value
   - =Min-Value(state, \alpha, \beta)= :: returns a utility value

   #+BEGIN_EXAMPLE
Alpha-Beta-Search(state) {
  v = Max-Value(state, -999, +999);
  return action in ACTIONS with value v;
}

Max-Value(state, alpha, beta) {
  v = INT_MIN;
  for each a in ACTIONS(state) do
    v = Max(v, Min-Value(result(s,a), alpha, beta));
    if v >= beta then return v;
    alpha = MAX(alpha,v);
  return v;
}
   #+END_EXAMPLE

* Constraint Satisfaction Problems
  It seems to formulate the search problems in a uniformed representation:
  - X :: a set of variables
  - D :: each has a domain of values
  - C :: a set of constraints for each of the variable

  The goal is to find the assignment of values to the variables, that satisfies the constraints.

** Advantage
   - it uses /general purpose heuristic/ rather than /problem-specific/ ones.

** Variations
   - continuous or discrete domain
   - finite or infinite domain
   - linear or non-linear constraint
   - unary or binary or high order constraint



* Logic
** entailment
Entailment: \beta \models \alpha, reads:
the sentence \beta entails the sentence \alpha
if and only if
\alpha is true in all worlds where \beta is true.

** Propositional logic
a.k.a. boolean logic.

logical equivalence;

| a                                   | b                                                            |
|-------------------------------------+--------------------------------------------------------------|
| \alpha \wedge \beta                 | \beta \wedge \alpha                                          |
| (\alpha \wedge \beta) \wedge \gamma | \alpha \wedge (\beta \wedge \gamma)                          |
| \alpha \Rightarrow \beta            | \neg \beta \Rightarrow \neg \alpha                           |
| \alpha \Rightarrow \beta            | \neg \alpha \vee \beta                                       |
| \alpha \Leftrightarrow \beta        | (\alpha \Rightarrow \beta) \wedge (\beta \Rightarrow \alpha) |

 - A sentence is /valid/ if it is true in all models.
   Deduction theorem: KB \models \alpha iff KB \Rightarrow \alpha is valid
 - A sentence is satisfiable if it is true in /some/ models.
   KB \models \alpha iff KB \wedge \neg \alpha is unsatisfiable.

Proof method:
- inference rules: transform the sentences to a normal form
- model checking: truth table

A clause is a disjunction of literals.
Factoring: the result clause keeps only one copy of each literal.

Conjunction: \wedge
Disjunction: \vee
CNF: conjunctive normal form. Conjunction of (disjunctions of literals).


Resolution algorithm: proof by contradiction.
I.e. to show KB \models \alpha, we show KB \wedge \neg \alpha is unsatisfiable.
The naming resolution is because, the pair of complementary literals is resolved.

 - Definite clause :: disjunction of literals with exactly one positive literal.


** First Order Logic
\wedge is the natural connective with \exists.
Using \Rightarrow as the main connective with \exists often causes errors:

\exists x At(x,ISU) \Rightarrow Smart(x)

is true if there's anyone who is not at ISU, which may not be what you want.

Properties:
| a                   | b                   | result    |
|---------------------+---------------------+-----------|
| \forall x \forall y | \forall y \forall x |           |
| \exists x \exists y | \exists y \exists x |           |
| \exists x \forall y | \forall y \exists x | not equal |
| \forall x           | \neg \exists x \neg |           |
| \exists x           | \neg \forall x \neg |           |

