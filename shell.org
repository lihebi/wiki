#+TITLE: Shell

 * source 只在本shell可用
 * export 声明为全局变量。只有全局变量可以被子shell继承

#+begin_src shell
find . -type f -name *.flac -exec mv {} ../out/ \;
du -sm * | sort -nr
#+end_src

* command interactions

** pipeline
each command execute in its own subshell.

#+begin_src shell
<cmd1> | <cmd2> # pipe
<cmd1> |& <cmd2> # it is short hand for:
<cmd1> 2>&1 | <cmd2>
#+end_src

The exit status of a pipeline is

 * the exist status of the last command
 * if ~pipefail~ option is enabled, the last command to exit with a non-zero status
 * if ~!~ precedes the pipeline, it is logical negation

** redirection
#+begin_src shell
ls > dirlist 2>&1
ls 2>&1 dirlist # wrong
&>word # the same as
>word 2>&1
&>>word # the same as
>>word 2>&1
<<< word # use string directly as input
#+end_src

** list

#+begin_src shell
<cmd1> && <cmd2>
<cmd1> || <cmd2>
<cmd1> & # background, return 0 immediately. input is redirected to /dev/null
<cmd1> ; <cmd2> # return status is the last one
#+end_src

** grouping
 * ~( list )~: a subshell is created, each command in list will execute in that shell
 * ~{ list; }~: semicolon or newline is needed. No subshell is created, commands will run in current shell.



* Control Flow
Any redirections apply to all commands within that compound, unless explicitly overwritten.

** loop
wherever a ';' appears, it may be replaced with one or more newlines.

#+begin_src shell
until test-commands; do consequent-commands; done
while test-commands; do consequent-commands; done
# if in words is not presented, it is as if ~in $@~ is there
for name [ [in [words ...] ] ; ] do commands; done
# if any expr is omit, it is like 1
for (( expr1 ; expr2 ; expr3 )) ; do commands; done
break
continue
#+end_src

** if
#+begin_src shell
if test-commands; then
  consequent-commands;
[elif more-test-commands; then
  consequent-commands;
[else alternative-consequents;]
fi
#+end_src

** case

#+begin_src shell
case word in
  pattern1 | pattern2) command-list ;;
  pattern) command-list ;& # continue with the next clause
  pattern) command-list ;;& # continue to test patterns in next clause
  pattern) command-list ;;
  *) default-cmd;;
esac
#+end_src

** select
#+begin_src shell
select name [in words ...]; do commands; done
#+end_src

 * if ~in words~ is omitted, it is ~in "$@"~.
 * PS3 will be the prompt for the selection
 * selection should be a number
 * anything else will cause the name to be set to null
 * the line read is saved in variable ~REPLY~

** (())
#+begin_src shell
(( exp ))
#+end_src

arithmetic expression is evaluated

** [[]]
#+begin_src shell
[[exp]]
#+end_src

evaluation of conditional expression

* Condition

| expr                              | meaning                         |
|-----------------------------------+---------------------------------|
| /                                 | <                               |
| ~-f file~                         | file exists and is regular file |
| ~-d file~                         | file exists and is directory    |
| ~-e file~                         | file exists                     |
| ~-e <file>~                       | 存在                            |
| ~-a <file>~                       | 更好的存在.(有时候-e会出错)     |
| ~-s file~                         | file exists and size > 0        |
| ~-L <file>~                       | 符号链接?                       |
| ~-r <file>~                       | 可读?                           |
| ~-w <file>~                       | 可写?                           |
| ~-x <file>~                       | 可执行?                         |
| ~<file1> -nt <file2>~             | newer than?                     |
| ~<file1> -ot <file2>~             | older than?                     |
|-----------------------------------+---------------------------------|
| ~-z string~                       | string is empty                 |
| ~-n string~                       | string is not empty             |
| ~string1 == string2~              | 相等? 也可直接用=               |
| ~string1 != string2~              |                                 |
|-----------------------------------+---------------------------------|
| ~[ num1 -eq num2 ]~               | -eq, -ne, -lt, -le, -gt, -ge    |
| ~(( num1 == num2 ))~              | ~== != > >= < <=~               |
|-----------------------------------+---------------------------------|
| ~[ false -a true ]~               | and                             |
| ~[ false -o true ]~               | or                              |
| ~[ !true ]~                       | not                             |
| ~\[\[ ture && false 11 ! true ]]~ |                                 |


** About [] [[]]
 * ~[~ is a synonym for test, and a builtin for efficiency. It is a command.
 * ~[[~ is a keyword, perform comparisons in a manner more familiar to programmers.


* diff and patch
#+begin_src shell
diff -u old new > patch
diff -Naur olddir newdir > patch
patch -p<num> <patch
#+end_src

* My Scripts

#+begin_src shell
# papers.txt contains titles of papers, one per line
# scholar.py is from web, an API-like project for Google Scholar
while read -r line; do
    ID=~./scholar.py -c 1 -t -p "\"$line\"" | grep "Cluster ID" | awk '{print $3}'~
    ./scholar.py -c 1 -C $ID --citation=bt >> out.bib
done < papers.txt
#+end_src

loop counter

#+begin_src shell
count=1
while read -r line; do
    echo $count
    let count=count+1
done < papers.txt
#+end_src

* Builtin Utilities
 * ~time <command>~: # the total user and system time consumed by the shell and its children
 * ~column~: formats its input into multiple columns. ~mount | column -t~
 * ~dd~: ~dd if=xxx.iso of=/dev/sdb bs=4m; sync~
 * ~convert~: ~convert xxx.jpg -resize 800 xxx.out.jpg # 800x<height>~
 * ~nl~: ~nl <filename>~ 添加行号。输出到stdout
 * ~ln~: ~ln -s <target> <linkname>~ 记忆：新的东西总要最后才发布。
 * ~ls~: order: ~-r~ reverse; ~-s~ file size; ~X~ extension; ~-t~ time
 * ~tree~
  * ~-d~ 只显示目录
  * ~-f~ 显示路径
  * ~-F~ 条目后有 [\*/=@|]
  * ~-r~ 倒序
  * ~-t~ 修改时间排序
  * ~-L(\d)~ 显示n层
 * ~cat~: ~-n~ output with line number
 * tail
  * ~-<n>~ 显示后n行
  * ~+<n>~ 显示第n行到结尾
  * ~-F~ 跟踪显示不断增长的文件结尾


** xargs
相当于~~，并把输出放 /结尾/
#+begin_src shell
find /etc -name '*.conf' | xargs ls -l
# the same as:
ls -l ~find ...~
#+end_src
** grep
#+begin_src shell
# -i: 忽略大小写
# -n: 显示行号
# -v: 输出不匹配的行
# -H: 同时输出此行所在的文件名
grep <pattern> <file>
#+end_src

** man

1. 普通用户可执行的命令
2. 系统调用手册，内核函数说明
3. 子程序手册，库函数说明
4. 系统设备手册，~/dev~目录中设备文件的参考说明
5. 配置文件格式手册
6. 游戏说明手册
7. 协议转换手册
8. 系统管理工具手册
9. linux系统例程手册

~man [num] <item>~
** find
Copy file based on find, and take care of quotes and spaces:
#+begin_src shell
find CloudMusic -type f -name "*mp3" -exec cp "{}" all_music \;
#+end_src


** tr: translate characters

tr <string1> <string2>

the characters in string1 are translated into the characters in string2
where the first character in string1 is translated into the first character in string2 and so on.  If string1 is longer than string2,
the last character found in string2 is duplicated until string1 is exhausted.

characters in the string can be:

any characters will represent itself if not:

 * ~\\octal~: A backslash followed by 1, 2 or 3 octal digits
 * ~\n~, ~\t~
 * ~a-z~: inclusive, ascending
 * ~[:class:]~: space, upper, lower, alnum
  - if ~[:upper:]~ and ~[:lower:]~ appears in the same relative position, they will correlate.

** uniq: report or filter out repeated lines in a file
Repeated lines in the input will not be detected if they are not adjacent,
so it may be necessary to sort the files first.

 * ~uniq -c~: Precede each output line with the count of the number of times the line occurred in the input, followed by a single space.
 * ~-u~: Only output lines that are not repeated in the input.
 * ~-i~: Case insensitive comparison of lines.

** sort
 * ~-n~: compare according to string numerical value
 * ~-r~: reverse


* IO
#+begin_src shell
read -p "please input: " a b c
echo -e "\n\thello\tworld\n" # 可以使用\n等控制字符
#+end_src



* Unix Management
 * id # 显示用户和组的信息
 * dmesg # 查看内核日志
 * uname
  * ~-v~ 内核版本 => ~Darwin Kernel Version 13.1.0: Wed Apr ... EASE_X86_64~
  * ~-r~ 内核发行信息 => ~13.1.0~
  * ~-m~ 机器硬件名称 => ~x86_64~
  * ~-n~ 网络节点。等价于~hostname~ => ~HebideMacBook-Pro.local~
  * ~-s~ 操作系统名称。 => ~Darwin~
  * 如果不加参数，默认使用 -s。 => ~Darwin~
 * strace ./a.out # details about system calls when a program runs
 * tcpdump -tt -r -nn xx.pcap
 * curl ifconfig.me
 * scp
  * ~scp <local> [ -p port ] root@hostname:<path>~
  * ~scp [-p port ] root@hostname:<path> <local>~
 * ldd a.out # 打印程序需要的shared lib
 * prompt($PS1-4)
  * ~\d~: date
  * ~\D{format}~
  * ~\h~: hostname
  * ~\H~: full hostname
  * ~\t~: time 24hour HH::MM::SS
  * ~\T~: time 12hour HH::MM::SS
  * ~\@~: time 12hour am/pm
  * ~\A~: time 24hour HH::MM
  * ~\w~: current working directory
  * ~\W~: basename of $PWD
** job control

 * C-Z suspend
 * refer a job
  - ~%n~: job number
  - ~%%~: current job
  - ~%+~: current job
  - ~%-~: previous job
  - ~%~: current job
  - ~%ce~: the job "ce"
  - ~%?ce~: the job, whose command has "ce"
 * fg %1: continue it in foreground
 * bg %1: continue it in background
 * jobs: list jobs
 * kill %1: kill the job
** return status
 * simple command: provided by POSIX 1003.1 ~waitpid~ function(less than 128)
 * if command terminated by signal ~n~, it is ~128+n~
 * all builtin returns 2 indicating incorrect usage


* Unix Shell Operation
 * ~Ctrl-s~ 停止显示
 * ~Ctrl-q~ 恢复显示

 * ~Shift-pageup/down~ pageup down
 * ~shift-Insert~ 粘贴。鼠标中键。

 * ~mkdir -p~ 同时建立父目录
 * ~Ctrl-l~ 清屏


* escape color

#+begin_src shell
#!/bin/bash
#
#   This file echoes a bunch of color codes to the
#   terminal to demonstrate what's available.  Each
#   line is the color code of one forground color,
#   out of 17 (default + 16 escapes), followed by a
#   test use of that color on all nine background
#   colors (default + 8 escapes).
#

T='gYw'   # The test text

echo -e "\n                 40m     41m     42m     43m\
     44m     45m     46m     47m";

for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' \
           '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' \
           '  36m' '1;36m' '  37m' '1;37m';
  do FG=${FGs// /}
  echo -en " $FGs \033[$FG  $T  "
  for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
    do echo -en "$EINS \033[$FG\033[$BG  $T  \033[0m";
  done
  echo;
done
echo
#+end_src

[[./img/bash-color.png]]

note:

 * 1: bold
 * 4: underline
 * 30-37: black, red, green, yellow, blue, pink, cyan, white
 * 40-47: background
 * 90-97: light
 * 100-107: light background

example:

 * ~\033[1;4;32;45m~
 * ~\e[32;45m~
 * ~\e[0m~

in PS1, use:

 * ~\[\033[32;45m\]~

* expansion
 * ~xxx~ <=> ~$(xxx)~

** brace expansion

#+begin_src shell
echo a{d,b,c}e
# => ade abe ace
mkdir /usr/local/{old,new,dist}
#+end_src

** tilde expansion

#+begin_src shell
~/foo # $HOME/foo
~hebi/foo # home of user hebi
#+end_src

** variable expansion
return value:

 * ~${var:-word}~: if var is unset or null, the value is expansion of word
 * ~${var:=word}~: if var is unset or null, the expansion of word is assigned to var
 * ~${var:?word}~: if var is unset or null, the expansion of word is written to stderr, shell exits.
  Otherwise the value of var is returned.
 * ~${var:+word}~: if var is unset or null, nothing returned. Otherwise expansion of word is returned.


** 变量替换

*返回结果，但不改变原变量的值。*

#+begin_src shell
# 若var未被声明，则以DEFAULT为其值
${var-DEFAULT}
${var=DEFAULT}
# 若
# 1. var 未被声明 或
# 2. 其值为空
# 则以DEFAULT为其值
${var:-DEFAULT}
${var:=DEFAULT}
#+end_src

string:

 * ~${str:offset}~: substr(offet)
 * ~${str:offset:length}~: substr(offset, count)
 * ~${#var}~: return length in character of the expansion of var
 * ~${str#word}~: pattern is the expansion of word.
  If the pattern matches the beginning of str,
  return the str with the **shortest** match of pattern in str deleted.
 * ~${str##word}~: the same as above, the **longest** match is deleted
 * ~${str%word}~: The tailing of str
 * ~${str%%word}~: longest
 * ~${str/pattern/string}~: longest match os pattern is replaced with string
  if pattern begins with
   - ~/~: all matched is replaced
   - ~#~: match must happen in the begin
   - ~%~: match must happen in the tail
 * ~${str^pattern}~: the match is converted from lower case to uppercase
 * ~${str^^pattern}~: all match
 * ~${str,pattern}~: upper to lower
 * ~${str,,pattern}~: all match

** filename expansion
 * ~*~: match any string, including null string
 * ~?~: match any single character
 * ~[...]~:
  - ~[a-dx-z]~
  - ~[!a-d]~
  - ~[^a-d]~
  - ~[[:digit:][:alnum:]]~

** 字符串

substring使用的是bash中的正则。

  * ~${#string}~ $string的长度
  * ~${string:5}~ $string 从5位置开始的子串
  * ~${string:5:3}~ 5位置开始，提取3个。
  * ~${string#substring}~ 从*开头*删除substring的*最短*匹配
  * ~${string##substring}~ 从*开头*删除substring的*最长*匹配
  * ~${string%substring}~ 从*结尾*删除substring的*最短*匹配
  * ~${string%%substring}~ 从*结尾*删除substring的*最长*匹配

  * ~${string/substring/replace}~ 第一个匹配的substring替换为replace
  * ~${string/#substring/replace}~ 开头是substring,则换为replace
  * ~${string/%substring/replace}~ 结尾时substring,则换为replace

substring若不加引号,则为正常字符串,加引号则可用$转义.

** 数值计算

#+begin_src shell
(( a=2+3 ))
a = $(( 2+3 ))

a = ((12))
echo $((a++)) # => 12
echo $((++a)) # => 14

echo ((5>3)) # => 1
#+end_src

* function

#+begin_src shell
name() compound-command [ redirections ]
function name [()] compound-command [ redirections ]
#+end_src

 * compound commands are often ~{ list; }~
 * if ~function~ keyword is present, ~()~ can be omitted.
 * function definition may be deleted by ~unset -f~
 * arguments to function become the positional parameters

* Script
** special parameters

  * ~$*~: "$1c$2c$3c...", c is the first character of $IFS
  * ~$@~: "$1" "$2" "$3" ...
  * ~$#~: the number of positional parameters
  * ~$?~: exit status
  * ~$-~: current option flags
  * ~$$~: process ID of the shell
  * ~$!~: process ID of the job most recently placed into the background
  * ~$0~:
  * ~$n~

** 特殊变量

#+begin_src shell
$0 # 脚本名称
$<n> # 第n个参数
$# # 参数数量
$* # 所有参数，作为一个字符串
$@ # 所有参数，作为字符串数组
#+end_src

#+begin_src shell
# example
./a.sh hello world
"$0" => ./a.sh
"$1" => hello
"$2" => world
"$#" => 2
"$*" => "./a.sh hello world"
"$@" => [ "./a.sh" "hello" "world" ]
#+end_src

#+begin_src shell
$$ # 当前进程的PID
$? # 上一个命令的返回值
$! # 运行在后台的最后一个进程的PID。done了也算。
$_ # 上个命令的最后一个字段
#+end_src
