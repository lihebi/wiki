#+TITLE: Pugixml

This is some frequently used APIs and functionalities I used.
For a complete reference, refer to http://pugixml.org.

* load

** parse result

#+begin_src C
struct xml_parse_result {
  xml_parse_status status;
  ptrdiff_t offset;
  xml_encoding encoding;

  operator bool() const;
  const char* description() const;
};
#+end_src

xml_parse_status

 * status_ok
 * status_file_not_found
 * ...

** parse options
The usual bitwise arithmetics: `mask | flag` and `mask & ~flag`.

 * parse_trim_pcdata: off. if the leading and trailing whitespace are to be removed.
 * parse_ws_pcdata: off. if PCDATA nodes that consist only of whitespace are to be sustained.
 * parse_minimal: all options turned off
 * parse_default
 * parse_full


** Load
*** from file
API:

#+begin_src C
xml_parse_result xml_document::load_file(
  const char* path,
  unsigned int options = parse_default,
  xml_encoding encoding = encoding_auto
);
#+end_src

example

#+begin_src C
pugi::xml_document doc;
pugi::xml_parse_result result = doc.load_file("tree.xml");
#+end_src

*** from memory
API:

#+begin_src C
// immutable buffer
xml_parse_result xml_document::load_buffer(
  const void* contents,
  size_t size,
  unsigned int options = parse_default,
  xml_encoding = encoding_auto
);
// equivalent with call load_buffer with size strlen(contents)
// null terminated string
xml_parse_result xml_document::load_string(
  const char_t* contents,
  unsigned int options = parse_default
);
#+end_src

examples:

#+begin_src C
const char source[] = "<hello>world</hello>";
size_t size = sizeof(source);
pugi::xml_parse_result result = doc.load_buffer(source, size);

pugi::xml_parse_result result = doc.load_string("<hello>world</hello>");
#+end_src

*** from IO streams
API:

#+begin_src C
xml_parse_result xml_document::load(
  std::istream& stream,
  unsigned int options = parse_default,
  xml_encoding encoding = encoding_auto
);
#+end_src

example:

#+begin_src C
std::ifstream stream("a.xml");
pugi::xml_parse_result result = doc.load(stream);
#+end_src

* read

if some node doesn't have name or value,
the function will return "".

node:

#+begin_src C
const char_t* xml_node::name() const;
const char_t* xml_node::value() const;
// value of the first child with type node_pcdata or node_cdata
const char_t* xml_node::child_value() const;
// wrapper for child(name).child_value()
const char_t* xml_node::child_value(const char_t* name) const;
#+end_src

attr:

#+begin_src C
const char_t* xml_attribute::name() const;
const char_t* xml_attribute::value() const;
// as_xx
int xml_attribute::as_int(int def = 0) const;
unsigned int xml_attribute::as_uint(unsigned int def = 0) const;
double xml_attribute::as_double(double def = 0) const;
float ...
bool ...
long long ...
unsigned long long ...
#+end_src

xml_text:

#+begin_src C
xml_text xml_node::text() const;
xml_node xml_text::data() const;
#+end_src

if the node is `node_pcdata` or `node_cdata`, return the node's data.
else, return the first child node of `node_pcdata` or `node_cdata`.

API:

#+begin_src C
bool xml_text::empty() const;
// equal to text.data().value()
const char_t* xml_text::get() const;
bool xml_text::set(const char_t* rhs);
#+end_src

as_xx:

#+begin_src C
const char_t* xml_text::as_string(const char_t* def = "") const;
int xml_text::as_int(int def = 0) const;
unsigned int xml_text::as_uint(unsigned int def = 0) const;
double xml_text::as_double(double def = 0) const;
float xml_text::as_float(float def = 0) const;
bool xml_text::as_bool(bool def = false) const;
long long xml_text::as_llong(long long def = 0) const;
unsigned long long xml_text::as_ullong(unsigned long long def = 0) const;
#+end_src

#+begin_src C
bool xml_text::set(int rhs);
bool xml_text::set(unsigned int rhs);
bool xml_text::set(double rhs);
bool xml_text::set(float rhs);
bool xml_text::set(bool rhs);
bool xml_text::set(long long rhs);
bool xml_text::set(unsigned long long rhs);
xml_text& xml_text::operator=(const char_t* rhs);
xml_text& xml_text::operator=(int rhs);
xml_text& xml_text::operator=(unsigned int rhs);
xml_text& xml_text::operator=(double rhs);
xml_text& xml_text::operator=(float rhs);
xml_text& xml_text::operator=(bool rhs);
xml_text& xml_text::operator=(long long rhs);
xml_text& xml_text::operator=(unsigned long long rhs);
#+end_src
* modify

** set
#+begin_src C
bool xml_node::set_name(const char_t* rhs);
bool xml_node::set_value(const char_t* rhs);
bool xml_attribute::set_name(const char_t* rhs);
bool xml_attribute::set_value(const char_t* rhs);
#+end_src

attribute can use different type other than string:

#+begin_src C
bool xml_attribute::set_value(int rhs);
bool xml_attribute::set_value(unsigned int rhs);
bool xml_attribute::set_value(double rhs);
bool xml_attribute::set_value(float rhs);
bool xml_attribute::set_value(bool rhs);
bool xml_attribute::set_value(long long rhs);
bool xml_attribute::set_value(unsigned long long rhs);
xml_attribute& xml_attribute::operator=(const char_t* rhs);
xml_attribute& xml_attribute::operator=(int rhs);
xml_attribute& xml_attribute::operator=(unsigned int rhs);
xml_attribute& xml_attribute::operator=(double rhs);
xml_attribute& xml_attribute::operator=(float rhs);
xml_attribute& xml_attribute::operator=(bool rhs);
xml_attribute& xml_attribute::operator=(long long rhs);
xml_attribute& xml_attribute::operator=(unsigned long long rhs);
#+end_src
** add/remove
node:

#+begin_src C
xml_node xml_node::append_child(xml_node_type type = node_element);
xml_node xml_node::prepend_child(xml_node_type type = node_element);
xml_node xml_node::insert_child_after(xml_node_type type, const xml_node& node);
xml_node xml_node::insert_child_before(xml_node_type type, const xml_node& node);
// node_element with tagname name
xml_node xml_node::append_child(const char_t* name);
xml_node xml_node::prepend_child(const char_t* name);
xml_node xml_node::insert_child_after(const char_t* name, const xml_node& node);
xml_node xml_node::insert_child_before(const char_t* name, const xml_node& node);
#+end_src

attr:

#+begin_src C
xml_attribute xml_node::append_attribute(const char_t* name);
xml_attribute xml_node::prepend_attribute(const char_t* name);
xml_attribute xml_node::insert_attribute_after(const char_t* name, const xml_attribute& attr);
xml_attribute xml_node::insert_attribute_before(const char_t* name, const xml_attribute& attr);
#+end_src

remove:

#+begin_src C
bool xml_node::remove_attribute(const xml_attribute& a);
bool xml_node::remove_attribute(const char_t* name);
bool xml_node::remove_child(const xml_node& n);
bool xml_node::remove_child(const char_t* name);
#+end_src

example:

#+begin_src C
// delete all nodes with specified name
while (node.remove_child("tool"));
#+end_src

** clone
node:

#+begin_src C
xml_node xml_node::append_copy(const xml_node& proto);
xml_node xml_node::prepend_copy(const xml_node& proto);
xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node);
xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node);
#+end_src

attr:

#+begin_src C
xml_attribute xml_node::append_copy(const xml_attribute& proto);
xml_attribute xml_node::prepend_copy(const xml_attribute& proto);
xml_attribute xml_node::insert_copy_after(
  const xml_attribute& proto,
  const xml_attribute& attr
);
xml_attribute xml_node::insert_copy_before(
  const xml_attribute& proto,
  const xml_attribute& attr
);
#+end_src

** move node
copy the node and remove the origin.
But this is expensive.
The following API avoid that.

#+begin_src C
xml_node xml_node::append_move(const xml_node& moved);
xml_node xml_node::prepend_move(const xml_node& moved);
xml_node xml_node::insert_move_after(const xml_node& moved, const xml_node& node);
xml_node xml_node::insert_move_before(const xml_node& moved, const xml_node& node);
#+end_src


* traversal

node:

#+begin_src C
xml_node xml_node::parent() const;
xml_node xml_node::first_child() const;
xml_node xml_node::last_child() const;
xml_node xml_node::next_sibling() const;
xml_node xml_node::previous_sibling() const;
xml_node xml_node::root() const;
// tag name
xml_node xml_node::child(const char_t* name) const;
xml_node xml_node::next_sibling(const char_t* name) const;
xml_node xml_node::previous_sibling(const char_t* name) const;
// find by attr
xml_node xml_node::find_child_by_attribute(
  const char_t* name,
  const char_t* attr_name,
  const char_t* attr_value
);
xml_node xml_node::find_child_by_attribute(
  const char_t* attr_name,
  const char_t* attr_value
);
#+end_src

attr:

#+begin_src C
xml_attribute xml_node::first_attribute() const;
xml_attribute xml_node::last_attribute() const;
xml_attribute xml_attribute::next_attribute() const;
xml_attribute xml_attribute::previous_attribute() const;
// tag name
xml_attribute xml_node::attribute(const char_t* name) const;
#+end_src

Attributes do not have a link to their parent nodes because of memory consumption reasons.

** range based loop(C++11)
#+begin_src C
implementation-defined-type xml_node::children() const;
implementation-defined-type xml_node::children(const char_t* name) const;
implementaiton-defined-type xml_node::attributes() const;
#+end_src

example

#+begin_src C
for (pugi::xml_node tool : tools.children("Tool")) {
  // ...
}
#+end_src

** iterators
API:

#+begin_src C
class xml_node_iterator;
class xml_attribute_iterator;

typedef xml_node_iterator xml_node::iterator;
iterator xml_node::begin() const;
iterator xml_node::end() const;

typedef xml_attribute_iterator xml_node::attribute_iterator;
attribute_iterator xml_node::attributes_begin() const;
attribute_iterator xml_node::attributes_end() const;
#+end_src

example

#+begin_src C
for (pugi::xml_node_iterator it=tools.begin();it!=tools.end();it++) {
  // it->xxx
}
#+end_src

** xml_tree_walker
API:

#+begin_src C
class xml_tree_walker {
public:
  virtual bool begin(xml_node& node);
  virtual bool for_each(xml_node& node) = 0;
  virtual bool end(xml_node& node);
  int depth() const;
};
bool xml_node::traverse(xml_tree_walker& walker);
#+end_src

 * `begin` is called with root
 * `for_each` is called for all nodes in Depth First Order, except root.
 * `end` is called with root

if `begin`, `end`, or any of `for_each` return false,
the traversal terminates and return false.

example

#+begin_src C
struct simple_walker : pugi::xml_tree_walker {
  virtual bool for_each(pugi::xml_node& node) {
    // node
    return true; // continue
  }
};
simple_walker walker;
doc.traverse(walker);
#+end_src

** simple path
#+begin_src C
string_t xml_node::path(char_t delimiter = '/') const;
xml_node xml_node::first_element_by_path(
  const char_t* path,
  char_t delimiter = '/'
);
#+end_src

path can be relative or absolute(start with delimiter).

* xpath

** types
`xpath_node` can be either a node or an attribute.

#+begin_src C
xml_node xpath_node::node() const;
xml_attribute xpath_node::attribute() const;
xml_node xpath_node::parent() const;
#+end_src

`xpath_node_set`

#+begin_src C
xpath_node xpath_node_set::first() const;
const xpath_node& xpath_node_set::operator[](size_t index) const;
size_t xpath_node_set::size() const;
bool xpath_node_set::empty() const;
#+end_src

** query
#+begin_src C
// equal to select_nodes().first()
xpath_node xml_node::select_node(
  const char_t* query,
  xpath_variable_set* variables = 0
) const;
xpath_node_set xml_node::select_nodes(
  const char_t* query,
  xpath_variable_set* variables = 0
) const;
// precompiled version
xpath_node xml_node::select_node(const xpath_query& query) const;
xpath_node_set xml_node::select_nodes(const xpath_query& query) const;
#+end_src

*** precompiled query
constructor:

#+begin_src C
explicit xpath_query::xpath_query(
  const char_t* query,
  xpath_variable_set* variables = 0
);
#+end_src

API:

#+begin_src C
bool xpath_query::evaluate_boolean(const xpath_node& n) const;
double xpath_query::evaluate_number(const xpath_node& n) const;
string_t xpath_query::evaluate_string(const xpath_node& n) const;
// equal to node.select_nodes()
xpath_node_set xpath_query::evaluate_node_set(const xpath_node& n) const;
// equal to node.select_node()
xpath_node xpath_query::evaluate_node(const xpath_node& n) const;
#+end_src
