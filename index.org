#+TITLE: Hebi's Personal Wiki

- [[file:proceedings.org][proceedings]]

A human needs to learn so so many things through his life. He can
master something at some period of time, but never think he can be
expert after a month not touching it. What happen next is looking into
various of manuals to get the memory back. The memory does help, but
not that much if the manual is not written in a uniform format. That's
the rational to create this page: a consistent format for all manuals.

Of course most of the material in this wiki are for programming
related because I'm not aware of some area having more various of
reference manuals than the area of computer science.

I'm talking about references, or manuals, not tutorials. At some point
when you get more comfortable at programing, tutorial should be some
easy-and-fun reading material rather than what you want to read in
your morning time.

The structure of the wiki is basically one page per topic, except some
large ones having sub-topics, like C family and the standard and
non-standard libraries. The index of the pages is on this page
only. It should contain entries to all the pages.

If you don't like my style of writing, and you like the idea, you are
always encouraged to create your own wiki. Head to
https://github.com/lihebi/wiki for the source files for this site if
you are interested.

-----
* Get everything organized
Get a [[file:linux.org][Linux]] distribution and enjoy the freedom and productivity after
a deep learning curve. My distribution path come along Ubuntu,
[[file:archlinux.org][ArchLinux]], gentoo, [[file:centos.org][CentOS]], [[file:debian.org][Debian]], then finally back to [[file:archlinux.org][ArchLinux]].  I
used debian for a long time and there's a page for [[file:debian-setup.org][setup]] of it.  I
installed linux for hundreds of times, if not thousands. [[file:liveusb.org][Live USB]].
Some terms related: [[file:posix.org][POSIX]] and [[file:samba.org][samba]].  I use [[file:stumpwm.org][StumpWM]] as my [[file:x11.org][X11]] window
manager.  [[file:tmux.org][Tmux]] for session manage. [[file:conkeror.org][conkeror]] used to be my default
browser but I go back to chromium because the performance.  [[file:docker.org][docker]] is
fantastic in that I can create a machine to play with very cheaply.

There're well-known discussion for what's the best editor to use. Vim
is good, and I used it for roughly 4 years when I'm in undergraduate
study. But I'll never recommand it after switching to [[file:emacs.org][Emacs]]. Yes,
Emacs is a full-fledged opearting system. Emacs is a much better
choice thanks a lot to the [[file:elisp.org][Emacs Lisp]] language. There're tons of [[file:emacs-plugins.org][Emacs
Plugins]] out there, and it is very easy and comfortable to extend the
editor by my own writing some lisp. The elisp is tightly bounded with
emacs editor functionalities, so there's a dedicated page for th [[file:emacs-lisp.org][Emacs
Part of Elisp]].  Although elisp is a good start point of lisp, it is
not general purpose, and can only run inside emacs. Another lisp
flavor, [[file:common-lisp.org][Common Lisp]] is more serious and practical lisp, the StumpWM is
written in it.  [[file:clojure.org][Clojure]] arise recently and the authors are advertising
it a lot. Many big player reside inside emacs, like the new reader
[[file:gnus.org][Gnus]].

* Programming
A project typically contains three parts: the main program and a bunch
of scripts to automate things, as well as documentation. For a
project, I use C family.  C family is the most fundamental
language. Almost all the new and fancy languages are written in C
family. So, never think they can have better performance than C. The
legacy [[file:c.org][C]] is small and elegent. It is a good /start point/ if you want
to learn serious compilers. C comes with [[file:c-lib.org][C standard library]]. C is
tightly related to Unix features, for example [[file:signal.org][Signal Handling]] for
C. [[file:cpp.org][C++]] is the language that achieve a good balance between performance
and morden features. It even continues to offer many fancy
features. C++ has a lot of libraries.  [[file:stl.org][Standard Template Library(STL)]]
defines containers and its algorithms.  The most functionalities not
specified in the standard librareis can often be found in [[file:boost.org][Boost]].  Some
[[file:cpp-lib.org][3rd-party C++ Libraries]] that is small enough to put into one page.
[[file:pugixml.org][Pugixml]] is Data processing libraries for xml.  Use [[file:google-test.org][Google Test]] for
unit testing.  Debugging using [[file:gdb.org][GDB]], of course. Here are some [[file:c-debug.org][C
debugging techniques]]. [[file:unix.org][Unix Programming]] Interface.

The area of [[file:compiler.org][compiler]] is interesting and pretty hard.  Some misc staff
for real-world [[file:compiler-impl.org][compiler implementation]].  [[file:make.org][make]], [[file:cmake.org][cmake]], [[file:autoconf.org][autoconf]] makes
the ecosystem of compilation.  Profiling of you code by [[file:gcov.org][gcov]],
[[file:gprof.org][gprof]]. When building compiler tools for [[file:program-analysis.org][Program Analysis]], [[file:llvm.org][LLVM]] and
[[file:clang.org][Clang]] toolchain can make it pretty easy.

Faminilar with [[file:design-pattern.org][Design Pattern]] when coding, and this can be learned
best by doing refactoring. 
# BTW refactoring is /THE/ most important
# thing to do no matter whatever the project is, even academic
# projects. If you can rewrite the sentence 10 times in your academic
# paper (I do this too), why you don't give the same priority to your
# code? Those who says refactoring is not important may simply because
# they have never written serious code to be useful or big enough to
# require a refactoring. In other word, TOY programs.

Scripting. [[file:./shell.org][shell]] concept and all [[file:shell-utils.org][shell utilities]] is
specified in POSIX standard.  [[file:awk.org][awk]] and [[file:sed.org][sed]] can make really elegent
scripts for simple tasks.  [[file:regex.org][Regular Expression]] is very important in
almost all unix scripting tasks. Moving to some more modern ones, I
found [[file:python.org][python]] now is pretty easy to use thanks to the pretty complete
[[file:python-std-lib.org][python standard libraries]] and it [[file:python-3rd-lib.org][python 3rd party libraries]], although
I'm stronly against using the stupid indent as part of syntax.  [[file:r.org][R]] is
very good at processing data, runs natively inside emacs.

* Writing
The 3rd part, Writing documentation, [[file:latex.org][latex]] is fantastic. [[file:tikz.org][tikz]] provide
the ultimate way to create academic figures.  [[file:markdown.org][markdown]] is not
recommanded from me. Instead I use [[file:org.org][Org Mode]] extensively.  [[file:doxygen.org][Doxygen]]
generates good documents and [[file:uml.org][UML]] figures using [[file:dot.org][Graphviz/Dot]].

* Misc
I got some of the notes from computation theory class.  [[file:math/511/np.org][NP]], [[file:math/511/np-problems.org][NP
problems]], [[file:math/531/NPC.org][NPC]], [[file:math/511/approximation.org][Approximation]], [[file:math/511/lp.org][Linear Programming]], [[file:math/531/tm.org][Turing Machine]],
[[file:math/531/decidability.org][Decidability]]. And some from AI class too: [[file:search-alg.org][Search algorithm]], [[file:name-alg.org][Name
Algorithm]], [[file:machine-learning.org][Machine Learning]], [[file:ai.org][Artificial Intelligence]]

I do some [[file:leetcode.org][Leetcode]] ocationally to keep a sense of fast implementation
of algorithm, but not much. Some related posts [[file:alg-string.org][String algorithms]],
[[file:palindrome.org][Palindrome]], [[file:data-structure.org][data structure]], [[file:data-structure-old.org][old data structure page]], [[file:oj.org][algorithm in
practice]].

