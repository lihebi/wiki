#+TITLE: Name Algorithm

* Aho Corasick

It is a multiple string match algorithm. =fgrep= is based on this.


** Construct Trie

https://farm8.staticflickr.com/7572/16085105388_86fedb2235_o.png

dictionary: ={a,ab,bab,bc,bca,c,caa}=

*** Node

The data structure has one node for every prefix of every string in the dictionary.
So if (bca) is in the dictionary,
then there will be nodes for (bca), (bc), (b), and ().

*** Color

If a node is in the dictionary then it is blue node.
Otherwise it is a grey node.

*** blue arc

a blue directed "suffix" arc from each node to the node that is the longest possible strict suffix of it in the graph.
For example, for node (caa), its strict suffixes are (aa) and (a) and ().
The longest of these that exists in the graph is (a).
So there is a blue arc from (caa) to (a).

*** Green Arc

There is a green "dictionary suffix" arc from each node to the next node in the dictionary that can be reached by following blue arcs. For example, there is a green arc from (bca) to (a) because (a) is the first node in the dictionary (i.e. a blue node) that is reached when following the blue arcs to (ca) and then on to (a).

** Match Process

At each step, the current node is extended by finding its child,
and if that doesn't exist, finding its suffix's child,
and if that doesn't work, finding its suffix's suffix's child,
and so on, finally ending in the root node if nothing's seen before.

* Barrel shifter

A barrel shifter is a digital circuit that can shift a data word
by a specified number of bits in one clock cycle.

https://farm8.staticflickr.com/7578/16260221182_53a096f18c_o.png

In the above image, x is input and y is output.

For shift 1, all the erjiguan on the green line exist, while others not.

** shift register

https://farm9.staticflickr.com/8671/16074934899_03921f148b_o.png

F0、F1、F2、F3是四个边沿触发的D触发器，每个触发器的输出端Q接到右边一个触发器的输入端D。
因为从时钟信号CP的上升沿加到触发器上开始到输出端新状态稳定地建立起来有一段延迟时间，
所以当时钟信号同时加到四个触发器上时，
每个触发器接收的都是左边一个触发器中原来的数据(F0接收的输入数据D1)。
寄存器中的数据依次右移一位。

* Bloom Filter

It is used to judge whether an item is in a set or not.

If bloom() return false, it is false. But if bloom() return true,
it may not be true.

The basic idea is, hash(item), map it in a vector of m size.
The vector is 0 initially.
v[hash(item)] is set to 1.
To reduce fault rate, use k hash functions.

To verify, only if all k hash functions has 1 in the vector will it return true.
Otherwise return false.

* Boyer Moore

It is a string match algorithm.

The rule lookup is in a hash table,
which can be formed during proprocessing of pattern.

** Bad Character Rule

#+begin_src text
- - - - X - - K - - -
A N P A n M A N A M -
- N n A A M A N - - -
- - - N n A A M A N -
#+end_src

from right end to left.
when a mismatch happens at `n`,
find to left a `n`, then shift it to the position.

** Good Suffix Rule

#+begin_src text
- - - - X - - K - - - - -
M A N P A n a m A N A P -
A n a m P n a m - - - - -
- - - - A n a m P N A M -
#+end_src

when a mismatch happens,
=nam= is the longest good suffix.
Find =nam= to the left,
and shift it to the position.

** Galil Rule

As opposed to shifting, the Galil rule deals with speeding up the actual comparisons done at each alignment by skipping sections that are known to match.
Suppose that at an alignment k1,
P is compared with T down to character c of T.
Then if P is shifted to k2 such that its left end is between c and k1,
in the next comparison phase a prefix of P must match the substring T[(k2 - n)..k1].
Thus if the comparisons get down to position k1 of T,
an occurrence of P can be recorded without explicitly comparing past k1.
In addition to increasing the efficiency of Boyer-Moore,
the Galil rule is required for proving linear-time execution in the worst case.

* Linear congruential generator

A linear congruential generator (LCG)
is an algorithm that yields a sequence of pseudo-randomized numbers.

pseudorandom number generator algorithms(PRNG).

$X_{n+1} = (aX_n+c) mod m$

X array is the pseudorandom.

 * $X_0$: seed
 * =m=: modulus
 * =a=: multiplier
 * =c=: increment

If c = 0,
the generator is often called a multiplicative congruential generator (MCG),
or Lehmer RNG.
If c ≠ 0, the method is called a mixed congruential generator.

* prefix tree

Alias: =Trie=, =Prefix Tree=, =Radix Tree=

It is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings


https://farm8.staticflickr.com/7527/16078670017_18478a43e5_o.png


** Radix Tree

A radix tree (also patricia trie or radix trie or compact prefix tree) is a space-optimized trie data structure where each node with only one child is merged with its parent.

Unlike in regular tries, edges can be labeled with sequences of elements as well as single elements.

https://farm8.staticflickr.com/7533/16264560645_3ec5648d69_o.png

* Rabin-Karp Algorithm

It is a string searching algorithm.

The Naive Solution for string search:

#+begin_src C
int func(char s[], int n, char pattern[], int m) {
  char *ps,*pp; //*
  ps=s;
  pp=pattern;
  for (i=0;i<n-m+1;) {
    if (*pp=='\0') return i; //*
    if (*ps == *pp) { //*
      ps++;pp++;
    } else {
      i++;
      ps=s+i;
      pp=pattern;
    }
  }
}
#+end_src

The running time is $O(mn)$.

The Rabin-Karp algorithm use hash for pattern match.
First calculate ~hash(pattern)~.
Then for every s[i,i+m-1], calculate the hash.
Then compare them.

The key of the algorithm is the hash function.
If the hash function need time m to compute, then it is still $O(mn)$.
If the collision happens often, then even if hash matches, we still need to verify.

Key point is to select a hast function, such that =hash(i,i+m-1)= can be computed
by ~hash(i-1,i+m-2)~.

If add all characters' ASCII together, collision is often.

The used hash function is:
select a large prime as base, 101 for example.
Hash value is:

\begin{equation}
hash("abc") = ASCII('a')*101^2 + ASCII('b')*101^1 + ASCII('c')*101^0
\end{equation}

Rabin-Karp is not so good for single string match because the worst case is $O(mn)$,
but it is the algorithm of choice for multiple pattern search.

K patterns, in a large string s, find any one of the K patterns.

* Rolling Hash

** Rabin-Karp rolling hash

** Cyclic Polynomial (Buzhash)

=s(a)= means shift a left.

\begin{equation}
H=s^{k-1}(h(c_1)) \oplus s^{k-2}(h(c_2)) \oplus \ldots \oplus s(h(c_{k-1})) \oplus h(c_k)
\end{equation}

=h= is a tabulation hashing.

To remove $c_1$ and add $c_{k+1}$:

\begin{equation}
H = s(H) \oplus s^k(h(c_1)) \oplus h(c_{k+1})
\end{equation}

* Tabulation hashing

input key is =p= bits, output is =q= bits.
choose a =r= less then =p=, and $t=\lceil p/r \rceil$.

view a key as t r-bit numbers. Use a lookup table filled with random values
to compute hash value for each of t numbers. Xor them together.

The choice of r should be made in such a way that this table is not too large,
so that it fits into the computer's cache memory.
